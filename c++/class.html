<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-04-15 Wed 11:30 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Class</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Tian" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/worg.min.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="sitemap.html"> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div><div id="content">
<h1 class="title">Class</h1>

<div id="outline-container-orgf8c56c8" class="outline-2">
<h2 id="orgf8c56c8">面向对象程序设计</h2>
<div class="outline-text-2" id="text-orgf8c56c8">
<p>
面向对象程序设计基于三个基本概念：数据封装、继承和动态绑定。通过数据封装我们可以实现接口与实现分离；使用继承可以定义相似
的类型并对其相似关系建模；使用动态绑定可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。
</p>
</div>
</div>
<div id="outline-container-orgd05606a" class="outline-2">
<h2 id="orgd05606a">数据封装</h2>
<div class="outline-text-2" id="text-orgd05606a">
<p>
<b>重要概念1</b>:数据封装 在面向对象编程中，数据封装(encapsulation)是指将对象的实现细节隐藏起来，用户通过
公共的接口来使用类。封装是通过访问控制(public,private,protect)实现的。
</p>

<p>
<b>rule:</b>
</p>
<ol class="org-ol">
<li>类的名称通常首字母大写；</li>
<li>数据成员通常前缀‘m_’，用来区别函数形参和函数的局部变量；</li>
</ol>
<p>
在类中定义的成员包括：
</p>
<ol class="org-ol">
<li>data member
<ul class="org-ul">
<li>non-static(对象属性)</li>
<li>static(类属性)</li>
</ul></li>
<li>member function
<ul class="org-ul">
<li>non-static</li>
<li>static</li>
<li>virtual</li>
</ul></li>
<li>type member</li>
</ol>

<p>
其中 data member 是一个类的核心，通常是对外隐藏的，通常需要通过 member function 来操作类的数据成员。非静态的数据成员在每
一个类对象中都有一个副本，而静态的数据成员只有一个副本，保存在程序的静态存储区，为该类的所有对象所共享。类的成员函数并不
保存在类的 <a href="#org4dbfe41">对象的内存</a>中 ，后者最多保存指向 vtable 的 vptr ,而这对于<a href="#orgae62a0d">多态</a>是至关重要的。
其中类型成员通常出现在类开始的地方 <a href="#org095699a">No description for this link</a>。
</p>
</div>
<div id="outline-container-orgd256320" class="outline-3">
<h3 id="orgd256320">引入this指针</h3>
<div class="outline-text-3" id="text-orgd256320">
<p>
既然类的对象中不保存成员函数，那么通过对象调用成员函数时，成员函数是如何准确知道是哪个对象调用它，进而获取该对象的数据成
员的呢？
答案就是 <code>this</code> 指针。在每个non-static member function 中都隐含了一个this指针，用于指向调用它的对象。默认情况下this 指针
的类型是 <code>T*const this</code>,我们不能改变this 中保存的地址。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-type">A</span> <span class="org-variable-name">a</span>;
<span class="linenr">2: </span>a.func<span class="org-rainbow-delimiters-depth-1">()</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#31561;&#20215;&#20110;&#65306; A::func(&amp;a);</span>
</pre>
</div>

<p>
<i>新的问题：</i> 因为this 指针不是一个“指向常量的指针”，如果我们的对象被声明为常量，岂不是会调用出错吗？比如：
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-keyword">class</span> <span class="org-type">A</span>
<span class="linenr"> 2: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 3: </span><span class="org-keyword">public</span>:
<span class="linenr"> 4: </span>    <span class="org-function-name">A</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
<span class="linenr"> 5: </span>    ~<span class="org-function-name">A</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
<span class="linenr"> 6: </span>    <span class="org-type">void</span> <span class="org-function-name">test</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
<span class="linenr"> 7: </span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr">10: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">11: </span>    <span class="org-keyword">const</span> <span class="org-type">A</span> <span class="org-variable-name">a</span>;
<span class="linenr">12: </span>    a.test<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="linenr">13: </span>    <span class="org-keyword">return</span> 0;
<span class="linenr">14: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">15: </span>
</pre>
</div>

<p>
如果编译的话会报错：
</p>
<pre class="example">
error: passing ‘const A’ as ‘this’ argument discards qualifiers [-fpermissive]
</pre>


<p>
那么如何把this 指针变成“指向常量的指针”呢？答案是在函数的形参列表后面、函数体之前添加 <code>const</code>,这个 <code>const</code> 会使this 指针
变为 <code>const T*const this</code> 类型。因此上例中的 <code>test()</code> 应该改写为 <code>void test()const{}</code>,这种成员函数又叫做 <b>常量成员函数</b>
(const member function),它们只可以读取调用它们的对象的数据成员，但是不能写入新值。
<b><i>正是由于 <code>this</code> 指针的限制，常量对象，以及常量对象的引用或指针都只能调用常量成员函数</i></b>
</p>
</div>
</div>
<div id="outline-container-org190d67d" class="outline-3">
<h3 id="org190d67d">类的作用域与名字查找 <a id="org095699a"></a></h3>
<div class="outline-text-3" id="text-org190d67d">
</div>
<div id="outline-container-org3825ce0" class="outline-4">
<h4 id="org3825ce0">类的作用域</h4>
<div class="outline-text-4" id="text-org3825ce0">
<p>
一个类就是一个作用域，在类的外部，成员的名字被隐藏起来了，因此当我们在类的外部定义成员函数时必须同时提供类名和函数名，一
旦遇到类名，定义的剩余部分（参数列表和函数体）其中类的作用域之内了。
</p>
</div>
</div>
<div id="outline-container-org6e5d993" class="outline-4">
<h4 id="org6e5d993">名字查找 (name lookup)</h4>
<div class="outline-text-4" id="text-org6e5d993">
<p>
对于成员函数体中使用的名字：编译器处理完类中的全部声明后才会处理成员函数的定义，所以成员函数可以使用类中定义的任何名字。
对于声明（包括返回类型和参数列表中）中使用的名字：必须在使用前声明，确保可见。
</p>
<ol class="org-ol">
<li>type member
类的type member 在类内可以直接使用，在另外需要通过作用域运算符（::）访问，为了确保type member 在类内可以被所有使用它的成
员可见，通常江type member 放在类的开始处。另外还有一点需要特别注意，在类内不能重新定义一个在外层作用域中的名字。</li>
<li>成员函数中使用的名字按照如下方式解析：
<ul class="org-ul">
<li>在成员函数内查找该名字的声明，只有在函数使用之前出现的声明才被考虑</li>
<li>如果在函数内没找到，则在类内继续查找，这时类的所有成员都可以考虑</li>
<li>如果类内也没找到，在成员函数定义之前的作用域内继续查找</li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org71b1606" class="outline-3">
<h3 id="org71b1606">数据成员的初始化</h3>
<div class="outline-text-3" id="text-org71b1606">
<p>
类内数据成员的这四个过程是通过四个函数实现的。如果我们没有为类主动定义這些函数，那么编译器将为我们合成一个默认的版本，
</p>
</div>
<div id="outline-container-org2447749" class="outline-4">
<h4 id="org2447749">构造函数(Constructor)</h4>
<div class="outline-text-4" id="text-org2447749">
<p>
当我们创建一个类的对象时，编译器才会为这个对象分配内存空间并使用构造函数初始化类对象的数据成员，构造函数不能声明为const
的，因为我们创建一个类的const 对象时，直到构造函数完成初始化过程，对象才能取得其“常量”属性。因此构造函数在const 对象得构
造过程中可以向其写值。
</p>
</div>
<ul class="org-ul">
<li><a id="orgfd420dd"></a>默认构造函数<br />
<div class="outline-text-5" id="text-orgfd420dd">
<p>
如果我们没有显式的声明一个构造函数，那么编译器会为我们隐式的定义一个默认构造函数，由编译器创建的默认构造函数又被称为 <b>合成的默认构造函数</b>
(synthesized default constructor),对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：
</p>
<ul class="org-ul">
<li>如果存在类内初始值，则用它来初始化类的成员</li>
<li>否则默认初始化该成员</li>
</ul>
<p>
需要注意得是一旦我们定义了一些其它的构造函数，那么除非我们再定义一个默认得构造函数，否则类将没有默认构造函数。我们不能寄
希望与编译器合成的默认构造函数，因为在一些含有指针或数组成员的类、被包含的类成员中，编译器合成的默认构造函数是无法完成任
务的，有时候是很无效的和危险的。
</p>

<p>
当我们自己写默认构造函数时，可以直接空着形参列表，也可以将形参全部带有默认值。默认构造函数的作用：
当对象被默认初始化或值初始化时自动执行默认构造函数。
</p>
<ol class="org-ol">
<li>默认初始化
<ul class="org-ul">
<li>当我们在块作用域内不使用任何初始值定义一个非静态变量或数组时；</li>
<li>当一个类本身含有类类型的成员且使用合成的默认构造函数时；</li>
<li>当类类型的成员没有在构造函数初始化列表中显式的初始化时。</li>
</ul></li>
<li>值初始化
<ul class="org-ul">
<li>在数组初始化中如果我们提供的初始值数量少于数组大小时</li>
<li>当我们不使用初始值定义一个局部静态变量</li>
<li>当我们通过书写 <code>T()</code> 的表达式显式请求值初始化时，其中 <code>T</code> 时类型名</li>
</ul></li>
</ol>
</div>
</li>

<li><a id="org232c019"></a>初始化数据成员<br />
<div class="outline-text-5" id="text-org232c019">
<p>
构造函数通过 <b>类内初始值</b> 或 <b>初始值列表</b> 来初始化类的数据成员，而在构造函数的函数体内完成的是赋值操作。
数据成员的初始化顺序与它们在类中声明的顺序一致。没有出现在初始值列表中的成员将通过相应的类内初始值来初始化，或者执行默认
初始化。如果一个数据成员既有类内初始值，又出现在初始值列表中，那么初始值列表会覆盖类内初始值。
</p>
</div>
</li>
<li><a id="org553a682"></a>特殊成员的初始化<br />
<div class="outline-text-5" id="text-org553a682">
<p>
有时我们可以忽略数据成员初始化和赋值的区别，但并不总是这样，比如成员是const、引用或者某种未提供默认构造函数的类类型，我
们必须为這些成员提供初值。
</p>
</div>
</li>
<li><a id="orgc9906c8"></a>成员初始化顺序<br />
<div class="outline-text-5" id="text-orgc9906c8">
<p>
成员的初始化顺序与其在类内的声明顺序一致，而与在初始化列表中出现的顺序无关。
</p>
</div>
</li>
<li><a id="orgf12a1a4"></a>委托构造函数 (delegating constructor)<br />
<div class="outline-text-5" id="text-orgf12a1a4">
<p>
这是C++11新标准增加的一个功能，一个委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程。受委托的构造函数放在委
托构造函数的初始化列表位置，在创建对象时，依次执行受委托构造函数的初始化列表和函数体，最后执行委托构造函数的函数体。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-keyword">class</span> <span class="org-type">SalesData</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">2: </span><span class="org-keyword">public</span>:
<span class="linenr">3: </span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#38750;&#22996;&#25176;&#26500;&#36896;&#20989;&#25968;&#20351;&#29992;&#23545;&#24212;&#30340;&#23454;&#21442;&#21021;&#22987;&#21270;&#25104;&#21592;</span>
<span class="linenr">4: </span>    <span class="org-function-name">SalesData</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">s</span>,<span class="org-type">unsigned</span> <span class="org-variable-name">cnt</span>,<span class="org-type">double</span> <span class="org-variable-name">price</span><span class="org-rainbow-delimiters-depth-2">)</span>:m_bookNo<span class="org-rainbow-delimiters-depth-2">(</span>s<span class="org-rainbow-delimiters-depth-2">)</span>,m_units_sold<span class="org-rainbow-delimiters-depth-2">(</span>cnt<span class="org-rainbow-delimiters-depth-2">)</span>,m_revenue<span class="org-rainbow-delimiters-depth-2">(</span>cn*price<span class="org-rainbow-delimiters-depth-2">){}</span>
<span class="linenr">5: </span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20854;&#20313;&#30340;&#26500;&#36896;&#20989;&#25968;&#20840;&#37096;&#22996;&#25176;&#32473;&#21478;&#19968;&#20010;&#26500;&#36896;&#20989;&#25968;</span>
<span class="linenr">6: </span>    <span class="org-function-name">SalesData</span><span class="org-rainbow-delimiters-depth-2">()</span>:SalesData<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">""</span>,0,0<span class="org-rainbow-delimiters-depth-2">){}</span>
<span class="linenr">7: </span>    <span class="org-function-name">SalesData</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">)</span>:<span class="org-variable-name">SalesData</span><span class="org-rainbow-delimiters-depth-2">(</span>s,0,0<span class="org-rainbow-delimiters-depth-2">){}</span>
<span class="linenr">8: </span>    <span class="org-function-name">SalesData</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">istream</span> <span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-2">)</span>:<span class="org-function-name">SalesData</span><span class="org-rainbow-delimiters-depth-2">(){</span>read<span class="org-rainbow-delimiters-depth-3">(</span>is,*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>;<span class="org-rainbow-delimiters-depth-2">}</span>
<span class="linenr">9: </span><span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</div>
</li>

<li><a id="orgad1e9cf"></a>隐式的类类型转换<br />
<div class="outline-text-5" id="text-orgad1e9cf">
<p>
除了c++语言的内置类型之间有自动转换规则以外，我们也可以为类定义隐式转换规则。*如果构造函数只接受一个实参，那我们就可以用
这种实参来转换为类类型，这种构造函数称为转换构造函数*,这种转换只允许一步类类型转换。
</p>

<p>
隐式的类类型转换是否有用完全看情况，如果在某些情况下我们不希望这种转换的话，我们可以使用 <code>explicit</code> 关键字阻止隐式转换，
具体做法是在构造函数的声明中使用该关键字，在类外部定义时不应重复写。 <code>explicit</code> 构造函数只能用于直接初始化，而不能用于拷
贝形式的初始化（使用＝）。
</p>

<p>
虽然编译器不会将 <code>explicit</code> 构造函数用于隐式类型转换过程，但是我们可以使用这样的构造函数显式的强制进行转换。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 2: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span class="org-keyword">class</span> <span class="org-type">SalesData</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 5: </span><span class="org-keyword">public</span>:
<span class="linenr"> 6: </span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#38750;&#22996;&#25176;&#26500;&#36896;&#20989;&#25968;&#20351;&#29992;&#23545;&#24212;&#30340;&#23454;&#21442;&#21021;&#22987;&#21270;&#25104;&#21592;</span>
<span class="linenr"> 7: </span>    <span class="org-function-name">SalesData</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">s</span>,<span class="org-type">unsigned</span> <span class="org-variable-name">cnt</span><span class="org-rainbow-delimiters-depth-2">)</span>:              <span class="org-comment-delimiter">// </span><span class="org-comment">#1</span>
<span class="linenr"> 8: </span>        m_bookNo<span class="org-rainbow-delimiters-depth-2">(</span>s<span class="org-rainbow-delimiters-depth-2">)</span>,m_units_sold<span class="org-rainbow-delimiters-depth-2">(</span>cnt<span class="org-rainbow-delimiters-depth-2">){}</span>
<span class="linenr"> 9: </span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20854;&#20313;&#30340;&#26500;&#36896;&#20989;&#25968;&#20840;&#37096;&#22996;&#25176;&#32473;&#21478;&#19968;&#20010;&#26500;&#36896;&#20989;&#25968;</span>
<span class="linenr">10: </span>    <span class="org-function-name">SalesData</span><span class="org-rainbow-delimiters-depth-2">()</span>:SalesData<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">""</span>,0<span class="org-rainbow-delimiters-depth-2">){}</span>                       <span class="org-comment-delimiter">// </span><span class="org-comment">#2</span>
<span class="linenr">11: </span>    <span class="org-keyword">explicit</span> <span class="org-function-name">SalesData</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">)</span>:<span class="org-variable-name">SalesData</span><span class="org-rainbow-delimiters-depth-2">(</span>s,0<span class="org-rainbow-delimiters-depth-2">){}</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">#3</span>
<span class="linenr">12: </span>    <span class="org-function-name">SalesData</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unsigned</span> <span class="org-variable-name">u</span><span class="org-rainbow-delimiters-depth-2">)</span>:SalesData<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">""</span>,u<span class="org-rainbow-delimiters-depth-2">){}</span>             <span class="org-comment-delimiter">// </span><span class="org-comment">#4</span>
<span class="linenr">13: </span>
<span class="linenr">14: </span>    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">getBookNo</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">return</span> m_bookNo;<span class="org-rainbow-delimiters-depth-2">}</span>
<span class="linenr">15: </span>    <span class="org-type">unsigned</span> <span class="org-function-name">getUnitsSold</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">return</span> m_units_sold;<span class="org-rainbow-delimiters-depth-2">}</span>
<span class="linenr">16: </span>
<span class="linenr">17: </span><span class="org-keyword">private</span>:
<span class="linenr">18: </span>    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_bookNo</span>;
<span class="linenr">19: </span>    <span class="org-type">unsigned</span> <span class="org-variable-name">m_units_sold</span>;
<span class="linenr">20: </span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="linenr">21: </span>
<span class="linenr">22: </span><span class="org-type">void</span> <span class="org-function-name">printValue</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">SalesData</span>&amp; <span class="org-variable-name">item</span><span class="org-rainbow-delimiters-depth-1">){</span>
<span class="linenr">23: </span>    <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"m_bookNo: "</span>     &lt;&lt;item.getBookNo<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt;<span class="org-string">"\n"</span>
<span class="linenr">24: </span>             &lt;&lt;<span class="org-string">"m_units_sold: "</span>&lt;&lt;item.getUnitsSold<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt;<span class="org-string">"\n"</span>;
<span class="linenr">25: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">26: </span>
<span class="linenr">27: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr">28: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">29: </span>    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Implicit convertion using #4:\n"</span>;
<span class="linenr">30: </span>    printValue<span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">31: </span>    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"#3 don't allow implicit convertion:\n"</span>;
<span class="linenr">32: </span>    printValue<span class="org-rainbow-delimiters-depth-2">(</span>SalesData<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Test"</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">33: </span>    printValue<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">SalesData</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"explicit conversion using static_cast"</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">34: </span>
<span class="linenr">35: </span>    <span class="org-type">SalesData</span> <span class="org-variable-name">sd</span><span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">or SalesData sd = 2; is aloowed.</span>
<span class="linenr">36: </span>    <span class="org-type">SalesData</span> <span class="org-variable-name">sd1</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"TEST"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;  <span class="org-comment-delimiter">//</span><span class="org-comment">SalesData sd = std::string("TEST"); is not allowed!</span>
<span class="linenr">37: </span>
<span class="linenr">38: </span>    <span class="org-keyword">return</span> 0;
<span class="linenr">39: </span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<pre class="example">
Implicit convertion using #4:
m_bookNo:
m_units_sold: 2
#3 don't allow implicit convertion:
m_bookNo: Test
m_units_sold: 0
m_bookNo: explicit conversion using static_cast
m_units_sold: 0
</pre>


<p>
那么C++在数据封装后布局成本会增加么？答案是不会，因为在每一个class object 中都只
包含non-static data member,就像C struct 一样，而member function 虽然含在class 声
明之内，却不出现在object 之中，每一个non-inline member function 只会产生一个函数
实体，至于每一个”拥有零个或一个定义”的inline function 则会在每一个使用者(模块，
翻译单元)中产生一个函数实体。C++在布局及存取时间上主要的额外负担主要是由 virtual
引起的，包括：
</p>
<ul class="org-ul">
<li>virtual function 机制 用来支持一个有效率的执行期绑定</li>
<li>virtual base class 用来实现“多次出现在继承体系中的bass class 有一个单一而被共
享的实体”</li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orga8733c6" class="outline-4">
<h4 id="orga8733c6">赋值</h4>
<div class="outline-text-4" id="text-orga8733c6">
<p>
赋值运算符放在运算符重载里讲。
</p>
</div>
</div>
<div id="outline-container-orgc8d979a" class="outline-4">
<h4 id="orgc8d979a">销毁</h4>
<div class="outline-text-4" id="text-orgc8d979a">
<p>
该函数控制销毁对象时发生的行为
</p>
</div>
</div>
</div>
<div id="outline-container-org7450b44" class="outline-3">
<h3 id="org7450b44">字面值常量类</h3>
</div>
<div id="outline-container-org3a94081" class="outline-3">
<h3 id="org3a94081">静态成员</h3>
<div class="outline-text-3" id="text-org3a94081">
<p>
类的静态成员具有静态生存期，存在与任何对象之外，每一个类都只有一个静态数据成员，所有该类的对象都共享该类的静态数据成员；
类似的类的静态成员函数也不能与任何对象绑定在一起，它们 <b>不包含</b> <code>this</code> 指针，因此静态成员函数不能声明成 <code>const</code> 的，而且
也不能使用 <code>this</code> 指针。
</p>
</div>
<div id="outline-container-org09bab44" class="outline-4">
<h4 id="org09bab44">使用类的静态成员</h4>
<div class="outline-text-4" id="text-org09bab44">
<p>
我们可以使用作用域运算符(::)来直接访问静态成员(public)，也可以通过类的对象、引用、指针来访问静态成员。
</p>
</div>
</div>
<div id="outline-container-org4e3138b" class="outline-4">
<h4 id="org4e3138b">定义静态成员</h4>
<div class="outline-text-4" id="text-org4e3138b">
<p>
我们既可以在类的内部也可以在类的外部定义静态成员函数，当在类外部定义静态成员的时候，不能重复 <code>static</code> 关键字，该关键字只
出现在类内部的声明语句。
</p>

<p>
因为静态数据成员不属于类的任何一个对象，所以它们不是在创建类的对象时被定义的，这意味着它们不是由类的构造函数初始化的。通
常情况下我们必须在类的外部定义和初始化每个静态成员。例外情况是静态常量整型数据可以在类内初始化，然后在类的外部定义一下该
成员。
</p>
</div>
</div>
<div id="outline-container-org8fbd2fa" class="outline-4">
<h4 id="org8fbd2fa">静态成员与普通成员的比较</h4>
<div class="outline-text-4" id="text-org8fbd2fa">
<p>
由于静态成员独立于对象，因此在某些非静态数据成员可能非法的场合，静态成员却可以正常使用。比如：
</p>
<ul class="org-ul">
<li>静态数据成员可以是不完全类型，特别的可以是它所属的类类型，而非静态数据成员必须声明为它所属类的指针或引用。</li>
<li>静态数据成员可以用作默认实参，而非静态数据成员不可以。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0a9a48a" class="outline-3">
<h3 id="org0a9a48a">拷贝</h3>
<div class="outline-text-3" id="text-org0a9a48a">
<p>
拷贝构造函数的第一个参数必须是一个自身类类型的引用(通常是const引用),且额外参数都有默认值。如果我们没有为类主动定义拷贝构
造函数，编译器会为我们定义一个，称为合成拷贝构造函数，它从给定的对象中依次将每个非const 成员拷贝到正在创建的对象中。
</p>
</div>
</div>
<div id="outline-container-org36651bc" class="outline-3">
<h3 id="org36651bc">拷贝初始化</h3>
<div class="outline-text-3" id="text-org36651bc">
<p>
拷贝初始化和直接初始化都发生在对象的初始化阶段，直接初始化就是编译器使用参数来匹配构造函数(包括拷贝构造函数);拷贝初始化时，编译器使用＝运
算符右边的对象拷贝到正在创建的对象中，如果需要的话，还会进行类型转换。
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-comment-delimiter">//</span><span class="org-comment">&#30452;&#25509;&#21021;&#22987;&#21270;</span>
<span class="linenr">2: </span><span class="org-type">string</span> <span class="org-variable-name">dots</span><span class="org-rainbow-delimiters-depth-1">(</span>10,<span class="org-string">'.'</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="linenr">3: </span><span class="org-comment-delimiter">//</span><span class="org-comment">&#25335;&#36125;&#21021;&#22987;&#21270;</span>
<span class="linenr">4: </span><span class="org-type">string</span> <span class="org-function-name">s</span><span class="org-rainbow-delimiters-depth-1">(</span>dots<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="linenr">5: </span><span class="org-type">string</span> <span class="org-variable-name">s2</span> = dots;
<span class="linenr">6: </span><span class="org-type">string</span> <span class="org-variable-name">null_book</span> = <span class="org-string">"9-999-99999-9"</span>;
<span class="linenr">7: </span><span class="org-type">string</span> <span class="org-variable-name">nines</span> = string<span class="org-rainbow-delimiters-depth-1">(</span>100,<span class="org-string">'9'</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span class="org-keyword">class</span> <span class="org-type">Test</span>
<span class="linenr"> 4: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 5: </span><span class="org-keyword">public</span>:
<span class="linenr"> 6: </span>    <span class="org-function-name">Test</span><span class="org-rainbow-delimiters-depth-2">(){</span><span class="org-constant">std</span>::cout &lt;&lt;  <span class="org-string">"This  is default constructor\n"</span>;<span class="org-rainbow-delimiters-depth-2">}</span>
<span class="linenr"> 7: </span>    <span class="org-keyword">explicit</span> <span class="org-function-name">Test</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">_s</span><span class="org-rainbow-delimiters-depth-2">){</span><span class="org-constant">std</span>::cout &lt;&lt;  <span class="org-string">"This  is  constructor\n"</span>;<span class="org-rainbow-delimiters-depth-2">}</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>    <span class="org-function-name">Test</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Test</span>&amp; <span class="org-variable-name">other</span><span class="org-rainbow-delimiters-depth-2">){</span><span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"This is copy constructor\n"</span>;<span class="org-rainbow-delimiters-depth-2">}</span>
<span class="linenr">10: </span><span class="org-keyword">private</span>:
<span class="linenr">11: </span>    <span class="org-type">int</span> <span class="org-variable-name">s</span> =0;
<span class="linenr">12: </span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="linenr">13: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr">14: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">15: </span>    <span class="org-type">Test</span> <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">16: </span>    <span class="org-type">Test</span> <span class="org-variable-name">tt</span><span class="org-rainbow-delimiters-depth-2">(</span>t<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">17: </span>    <span class="org-type">Test</span> <span class="org-variable-name">ttt</span>=t;
<span class="linenr">18: </span>    <span class="org-keyword">return</span> 0;
<span class="linenr">19: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">20: </span>
</pre>
</div>

<pre class="example">
This  is  constructor
This is copy constructor
This is copy constructor
</pre>


<p>
对象在以下几种情况下会调用拷贝构造函数：
</p>
<ul class="org-ul">
<li>当我们以一个类的对象去初始化该类的另一个对象时</li>
<li>当我们以传值的方式为函数传递或返回一个对象时</li>
<li>执行拷贝初始化时（有时也会用移动构造函数）</li>
<li>用花括号列表初始化一个数组中元素或一个聚合类中的成员</li>
</ul>
<p>
当初始化标准库容器或是调用其 <code>insert</code> 或 <code>push</code> 成员时，容器中保存的实际上是一个副本，这个副本就是通过拷贝构造函数获得的；
与之相对，用 <code>emplace</code> 成员创建的元素都进行直接初始化。
</p>
</div>
<div id="outline-container-org6c79034" class="outline-4">
<h4 id="org6c79034">合成拷贝构造函数</h4>
<div class="outline-text-4" id="text-org6c79034">
<p>
由编译器合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中(不包括static成员),
</p>
</div>
</div>
</div>
<div id="outline-container-org1b77b61" class="outline-3">
<h3 id="org1b77b61">拷贝赋值运算符</h3>
<div class="outline-text-3" id="text-org1b77b61">
<p>
拷贝赋值发生在对象的赋值阶段。如果类没有定义自己的拷贝赋值运算符，那么编译器会为它合成一个。合成的拷贝赋值运算符会将右侧
运算对象的每个非static 成员赋值给左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。
</p>
</div>
</div>
<div id="outline-container-org1479afa" class="outline-3">
<h3 id="org1479afa">析构函数</h3>
<div class="outline-text-3" id="text-org1479afa">
<p>
析构函数执行与构造函数相反的操作：构造函数初始化对象的非static 数据成员，还可能在函数体中做一些其它工作；析构函数释放对
象使用的资源，并销毁对象的非static 数据成员。在一个析构函数中，首先执行函数体，然后按照初始化的逆序销毁成员。销毁类类型
的成员会调用它们自己的析构函数，内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。析构函数体自身不会不会直接销毁
成员，成员的销毁是在隐含的析构阶段进行的，函数体时作为成员销毁步骤之外的一部分进行的。需要特别说明的是，对于动态分配的内
存，只有使用 <code>delete</code> 显式要求释放空间时，类类型的对象才会自动调用其析构函数。
</p>
</div>
<div id="outline-container-org8b743b1" class="outline-4">
<h4 id="org8b743b1">合成析构函数</h4>
<div class="outline-text-4" id="text-org8b743b1">
<p>
当一个类没有定义一个自己的析构函数时，编译器会为它定义一个合成析构函数，合成析构函数的函数体为空。
</p>
</div>
</div>
</div>
<div id="outline-container-org25affe4" class="outline-3">
<h3 id="org25affe4">三/五法则</h3>
<div class="outline-text-3" id="text-org25affe4">
<ol class="org-ol">
<li>有三个基本操作可以控制类的拷贝操作：拷贝构造函数，拷贝赋值运算符和析构函数。在C++11新标准下还有移动构造函数和移动赋值
运算符。</li>
<li>需要析构函数的类也需要拷贝和赋值操作</li>
<li>需要拷贝操作的类也需要赋值操作，反之亦然</li>
</ol>
</div>
</div>
<div id="outline-container-org487b9b5" class="outline-3">
<h3 id="org487b9b5">使用 =default</h3>
<div class="outline-text-3" id="text-org487b9b5">
<p>
我们可以对具有合成版本的成员函数（默认构造函数或拷贝控制成员）使用 <code>=default</code> 来显式的要求编译器合成相应的函数的默认版本。
当我们在类内用 <code>=default</code> 修饰成员的声明时，合成的函数将隐式的声明为内联的，如果我们不希望合成的成员是内联函数，应该只对
成员的类外定义使用 <code>=default</code>.
</p>
</div>
</div>
<div id="outline-container-org1e74ebf" class="outline-3">
<h3 id="org1e74ebf">阻止拷贝</h3>
<div class="outline-text-3" id="text-org1e74ebf">
<p>
有些类可能不希望发生拷贝，比如iostream,那么如何阻止类对象的拷贝呢？主要有以下两种：
</p>
<ol class="org-ol">
<li><p>
private 拷贝控制
</p>

<p>
在C++11之前，可以通过声明（但不定义）private 的拷贝构造函数、赋值运算符来阻止任何拷贝该类型对象的企图：试图拷贝对象的用
户代码在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。
</p></li>
<li><p>
定义删除的函数
</p>

<p>
在新标准下，我们可以通过将拷贝构造函数和赋值运算符定义为删除的函数来阻止拷贝，删除的函数：虽然我们声明了它，但不能以
任何方式使用它。在函数的参数列表后加上 <code>=delete</code> 来指出我们希望将它定义为删除的。我们可以将除析构函数外的任何函数指定
为删除的。
</p></li>
</ol>

<p>
需要特别注意的是，如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则该类的对应的成员函数（构造、拷贝构造、赋值运算符
和析构函数）的合成版本将被定义为删除的。
</p>
</div>
</div>
<div id="outline-container-orgae9fda0" class="outline-3">
<h3 id="orgae9fda0">拷贝控制和资源管理</h3>
<div class="outline-text-3" id="text-orgae9fda0">
<p>
一个类的对象在拷贝时，它的行为看起来要么像一个值，要么像一个指针。像值意味着每个对象都有自己的独立的状态，改变副本不会影
响原对象，反之亦然；像指针则说明类的对象共享状态，副本和原对象使用相同的底层数据，改变副本会影响原对象，反之亦然。我们如
何拷贝指针成员决定了类在拷贝时是像值还是像指针：如果我们拷贝的是指针所指向的对象，那么类像值；，如果拷贝的是指针本身，那么
类像指针。需要特别注意的是，如果我们定义一个像指针的类，最好的方法是使用智能指针 <code>shared_ptr</code>,因为它会帮我们管理何时销毁
指针，否则我们需要在类中定义一个计数器。
</p>
</div>
</div>
<div id="outline-container-org808a3be" class="outline-3">
<h3 id="org808a3be"><span class="todo TODO">TODO</span> 交换操作</h3>
</div>
<div id="outline-container-org1791ff4" class="outline-3">
<h3 id="org1791ff4">动态内存管理</h3>
</div>
</div>
<div id="outline-container-org580d70b" class="outline-2">
<h2 id="org580d70b">继承</h2>
<div class="outline-text-2" id="text-org580d70b">
<p>
通过继承（inheritance）联系在一起的类构成一种层次关系。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各
自特有的成员。继承是 is-a 的关系，组合是 has-a 的关系，它们都可以让某个类的数据放在另一个类中，要确定使用继承还是组合可
以考虑一下是否需要共同的接口，如果需要的话就用继承。
</p>
</div>
<div id="outline-container-orgc6c6a48" class="outline-3">
<h3 id="orgc6c6a48">定义派生类</h3>
<div class="outline-text-3" id="text-orgc6c6a48">
<p>
直接或间接从基类继承来的类叫做派生类，继承类型有 <code>public</code> <code>protected</code> <code>private</code> 三种类型，在这里被称为 <b>派生访问说明符</b>,它
们决定了基类中的成员在派生类中的访问权限：
</p>
<dl class="org-dl">
<dt>public继承</dt><dd>基类的成员的访问权限在派生类中不变，公有成员还是公有成员，受保护成员还是受保护成员</dd>
<dt>protected继承</dt><dd>基类的公有成员和受保护成员在继承类中是受保护的</dd>
<dt>private继承</dt><dd>基类的公有成员和受保护成员在继承类中是私有的</dd>
</dl>
<p>
无论是哪种继承方式，派生类都无法直接访问基类中的私有成员,同时派生类的成员及友元可以直接访问从基类继承来的非私有成员。
我们还可以使用 <code>using</code> 声明语句 改变个别继承来的成员的访问权限，using 声明语句中的名字的访问权限由该语句之前的访问说明符
决定。需要注意的是派生类只能为那些它可以访问的名字提供using 声明。
</p>

<p>
防止继承：c++11新标准提供一种防止继承发生的方法，即在类名后加关键字 <code>final</code>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-keyword">class</span> <span class="org-type">NoDerived</span> <span class="org-keyword">final</span><span class="org-rainbow-delimiters-depth-1">{}</span>;
<span class="linenr">2: </span><span class="org-keyword">class</span> <span class="org-type">Last</span> <span class="org-keyword">final</span> : <span class="org-keyword">public</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">{}</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcbf9351" class="outline-3">
<h3 id="orgcbf9351">类型转换与继承</h3>
<div class="outline-text-3" id="text-orgcbf9351">
<p>
通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的
const 类型转换规则，但是存在继承关系的类是一个重要的例外：我们可以将基类的指针或引用绑定到派生类对象上，所以当使用基类的
指针或引用时，实际上我们并不清楚该引用或指针所绑定的真实类型。
</p>
</div>
<div id="outline-container-orgeb62673" class="outline-4">
<h4 id="orgeb62673">静态类型与动态类型</h4>
<div class="outline-text-4" id="text-orgeb62673">
<p>
静态类型是编译时已知的，是变量声明时的类型或表达式生成的类型；动态类型时变量或表达式表示的内存中的对象的类型，动态类型直
到运行时才可知。如果表达式既不是指针也不是引用，则它的动态类型永远与静态类型一致。
</p>
</div>
</div>
<div id="outline-container-orgd061693" class="outline-4">
<h4 id="orgd061693">up-casting &amp; down-casting</h4>
<div class="outline-text-4" id="text-orgd061693">
<p>
向上类型转换是指从派生类转换到基类，这是安全的，无需特意使用转换运算符指出，当使用 <span class="underline">对象</span> 进行向上类型转换时会发生 <span class="underline">对象
切割(object slice)</span> ，即使用派生类的对象初始化或赋值一个基类对象时，会调用基类的构造函数或赋值运算符，而参数就是派生类的
对象，切割掉不属于基类的哪部分；而当我们用派生类为基类的指针或引用初始化或赋值时，当基类含有虚函数时会发生多态。
向下类型转换是从基类转换到派生类，是不安全的。
</p>
</div>
</div>
</div>
<div id="outline-container-orgb12d309" class="outline-3">
<h3 id="orgb12d309">继承中的类作用域</h3>
</div>

<div id="outline-container-org535a40a" class="outline-3">
<h3 id="org535a40a">成员函数与继承</h3>
</div>
<div id="outline-container-orgcaaee83" class="outline-3">
<h3 id="orgcaaee83">访问控制与继承</h3>
</div>
</div>

<div id="outline-container-org6af83d9" class="outline-2">
<h2 id="org6af83d9">动态绑定 <a id="orgae62a0d"></a></h2>
<div class="outline-text-2" id="text-org6af83d9">
<p>
C++实现动态绑定的条件有三个：
</p>
<ol class="org-ol">
<li>使用地址（指针或引用）</li>
</ol>
<p>
如果直接使用对象会发生对象切割，切割时调用基类的构造函数或赋值运算符会设定vptr指向基类的vtable;使用地址不会调用任何构造
函数或运算符，只是会改变对目标地址内容和大小的解释方式。
</p>
<ol class="org-ol">
<li>有继承</li>
<li>有虚函数</li>
</ol>

<div class="org-center">
<p>
<b>C++ Object Model</b>
</p>
</div>
</div>
</div>
<div id="outline-container-org25fdf0a" class="outline-2">
<h2 id="org25fdf0a">C++ model</h2>
<div class="outline-text-2" id="text-org25fdf0a">
<p>
已知下面这个声明，我们在使用 <code>Point</code> 新建对象的时候，这个对象在内存中是如何表现
的？
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-keyword">class</span> <span class="org-type">Point</span>
<span class="linenr"> 2: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 3: </span><span class="org-keyword">public</span>:
<span class="linenr"> 4: </span>    <span class="org-function-name">Point</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">xval</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr"> 5: </span>    <span class="org-keyword">virtual</span> ~<span class="org-function-name">Point</span><span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="linenr"> 6: </span>    <span class="org-type">double</span> <span class="org-function-name">x</span><span class="org-rainbow-delimiters-depth-2">()</span><span class="org-keyword">const</span>;
<span class="linenr"> 7: </span>    <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">PointCount</span><span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span class="org-keyword">protected</span>:
<span class="linenr">10: </span>    <span class="org-keyword">virtual</span> <span class="org-type">ostream</span>&amp; <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ostream</span> &amp;<span class="org-variable-name">os</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span>;
<span class="linenr">11: </span>    <span class="org-type">double</span> <span class="org-variable-name">m_x</span>;
<span class="linenr">12: </span>    <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">m_point_count</span>;
<span class="linenr">13: </span><span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgeb9135b" class="outline-2">
<h2 id="orgeb9135b">C++对象模型的内存布局介绍 <a id="org4dbfe41"></a></h2>
<div class="outline-text-2" id="text-orgeb9135b">
<p>
在C++对象模型中，对待data member 和 member function 有以下几种情况：
</p>
<ul class="org-ul">
<li>data member
<dl class="org-dl">
<dt>static data member</dt><dd>存放在所有class object 之外</dd>
<dt>non-static data member</dt><dd>每一个class object 内都有</dd>
</dl></li>
<li>member function
<dl class="org-dl">
<dt>static/non-static function</dt><dd>存放在所有class object 之外</dd>
<dt>virtual function</dt><dd>一两个步骤支持之：
<ul class="org-ul">
<li>每一个class 产生出一堆指向 virtual functions 的指针，放在表格之中，这个表
格叫做 virtual table(<b>vtbl</b>)</li>
<li>每一个class object 被添加了一个指针，指向相关的 virtual table.通常这个指针
称为 <b>vptr</b>,vptr 的设置和重置都由每一个class 的 <code>constructor</code>,
<code>destructor</code> 和 <code>copy assignment</code> 运算符自动完成。每一个class所关联的
<i>type_info</i> object(用于支持runtime type identifucation,RTTI)也经由 virtual
table 被指出来，通常是放在表格的第一个slot处。</li>
</ul></dd>
</dl></li>
</ul>

<p>
因此， <code>Point</code> 对象的内存布局应该是这样的：
</p>

<p>
所以一个class object需要多少内存?一般而言要有：
</p>
<ul class="org-ul">
<li>其non-static data member 的总和大小</li>
<li>加上任何由于alignment 的需求而填补(padding)上去的空间</li>
<li>加上为了支持 virtual(虚函数或者虚基类) 而由内部产生的任何额外负担。</li>
</ul>
</div>
</div>
<div id="outline-container-org6f3be5c" class="outline-2">
<h2 id="org6f3be5c">指针的类型</h2>
<div class="outline-text-2" id="text-org6f3be5c">
<p>
一个指向整数类型的指针是如何与一个指向字符串类型的指针不同呢？从内存来看它们没什么不同，所有的指针都是一个机器地址而已，
它们的区别在于所寻址出来的对象类型不同，也就是数指针类型会教导编译器如何解释某个特定地址中的内存大小和内容。因此：
</p>
<ul class="org-ul">
<li><code>void*</code> 类型的指针只能用来存储地址，而不能进行其它操作，因为我们不知道保存在该地址中的内存大小和内容</li>
<li>类型转换其实是一种编译器指令，大部分情况下它并不改变一个指针所存的地址，它只影响“被指出的内存的大小和内容”的解释方式</li>
</ul>
</div>
</div>

<div id="outline-container-orgcd86777" class="outline-2">
<h2 id="orgcd86777">Data Member</h2>
<div class="outline-text-2" id="text-orgcd86777">
<p>
虽然我们大概知道了一个类对象所占用的内存怎么计算了，但是一个空类的对象占用内存是否为0?答案是否定的，一个空类的对象大小为
1,比如：
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr">2: </span><span class="org-keyword">class</span> <span class="org-type">X</span><span class="org-rainbow-delimiters-depth-1">{}</span>;
<span class="linenr">3: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr">4: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">5: </span>    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span>X<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="linenr">6: </span>    <span class="org-keyword">return</span> 0;
<span class="linenr">7: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">8: </span>
</pre>
</div>

<pre class="example">
1
</pre>

<p>
这是因为编译器在 <code>X</code> 中安插了一个 <code>char</code>,使得这个类的两个对象可以在内存中配置无二的地址，如果 <code>X</code> 中有数据，那么编译器就
不会安插这个 <code>char</code> 了。
</p>
</div>
<div id="outline-container-orgf450c37" class="outline-3">
<h3 id="orgf450c37">布局</h3>
<div class="outline-text-3" id="text-orgf450c37">
<ol class="org-ol">
<li>类中的static data member 保存在程序的静态存储区，在程序运行期间，无论类有多少个对象，甚至是零个，static data  member 都
只有一份实体，但是template class 的sttatic data member 行为稍有不同；</li>
<li>non-static data member,包括继承来的，直接保存在每一个对象中，它们在对象中的排列顺序和其被声明的顺序一致，在同一个
access section 中的members只要符合“较晚出现的members 在对象中有较高的地址”这一条即可，它们不一定得连续排列，不同得
access section 之间的排列顺序是不定的；</li>
<li>当类需要支持 virtual 特性时，编译器会合成额外的data member,比如 vptr,通常会放在最前面。</li>
</ol>
<p>
每一个支持 virtual 特性的类都有一个虚函数列表VTABLE,这个类的每个对象都有一个 vptr 指向对应的VTABLE.
</p>
</div>
</div>
<div id="outline-container-org50d4e5f" class="outline-3">
<h3 id="org50d4e5f">继承与布局</h3>
<div class="outline-text-3" id="text-org50d4e5f">
<p>
在 C++继承模型中，一个派生类所表现出来的东西是其自己的member 加上基类members 的总和，在大部分编译器中，基类的members 总
是先出现，但属于虚基类的除外。C++ 语言保证“出现在派生类中的base class subobject 有其完整原样性”
</p>
</div>
<div id="outline-container-org7566fd8" class="outline-4">
<h4 id="org7566fd8">普通单一继承</h4>
<div class="outline-text-4" id="text-org7566fd8">
<ol class="org-ol">
<li><p>
没有多态
</p>

<p>
当继承体系中没有多态时，派生类中的数据成员会放在基类数据成员的后面，并且保证基类的完整原样性。即基类数据成员要对齐以
后才能继续存放派生类数据成员。一般而言，不会增加空间或存取时间上的额外负担。
</p></li>
<li><p>
含有多态
</p>

<p>
当支持多态特性时会带来空间和存储时间的额外负担，主要是因为 vtable 的引入和 vptr 的设定，每个类都有一个 vtable,每个类
的对象中多了一个 vptr,这个虚指针一般是放在最前面的，此外每一个 virtual member function 的调用也比非虚函数复杂。
</p></li>
</ol>

<p>
单一继承提供了一种自然多态形式，是关于继承体系中基类和派生类之间的转换，派生类对象的内存布局以基类部分开始，属于自己“特
色”的部分被排在后面，因此把一个派生类的对象指定给基类（不管继承的深度有多深）的指针或引用，不需要编译器取调停或修改地址，
它可以很自然的发生，并且提供了最佳执行效率。
</p>

<p>
如果基类中没有虚函数，而派生类中包含虚函数，那么单一继承的自然多态就会被打破，在这种情况下把一个派生类对象转换为基类类型
就需要编译器的介入用以调整地址（因为 vptr）。在多重继承和虚拟机承的情况下，编译器的介入更有必要。
</p>
</div>
</div>
<div id="outline-container-org904dc6a" class="outline-4">
<h4 id="org904dc6a">多重继承</h4>
<div class="outline-text-4" id="text-org904dc6a">
<p>
多重继承的复杂度在于基类们的复杂关系。其问题主要发生在派生类和它第二或后继的基类之间的转换。当一个多重派生的对象，将其地
址指定给第一个基类指针或引用时，情况和单一继承相同；至于第二个及后继基类的地址指定操作则需要修改地址：加上或减去介于中间
的基类大小。
</p>

<p>
如果要存取第二个或后继基类中的一个数据成员，没有额外的成本，因为成员的位置在编译期间就固定了，因此存取数据成员只是一个简
单的 offset 运算。
</p>
</div>
</div>
<div id="outline-container-orge5933d3" class="outline-4">
<h4 id="orge5933d3">虚拟继承</h4>
<div class="outline-text-4" id="text-orge5933d3">
<p>
如果一个类含有一个或多个虚基类，那么将被分为两部分：一个不变局部和一个共享局部。不变局部中的数据不管后继如何演化，总是有
固定的offset(从object 的开头算起),所以这一部分可以直接存取；至于共享部分就是虚基类的部份，其位置会因为每次的派生操作而有
变化，所以它们只可以被间接存取，
</p>
</div>
</div>
</div>
<div id="outline-container-orgd435827" class="outline-3">
<h3 id="orgd435827">初始化</h3>
<div class="outline-text-3" id="text-orgd435827">
<p>
初始化放在构造函数（包括拷贝构造函数）中，如果一个类是通过继承得到的，那么这个类的构造过程在继承体系中是从上到下、从最顶
端到最底端的过程：
</p>
<ol class="org-ol">
<li>调用 virtual base classes constructors, 从左至右，从最深到最浅：
<ul class="org-ul">
<li>如果class 被列于初始化列表中，那么应该通过它的构造函数将参数穿过去，如果不在参数列表中，则调用默认构造函数</li>
</ul></li>
<li>调用base classes constructors,以它们的声明次序为顺序：
<ul class="org-ul">
<li>如果class 被列于初始化列表中，那么应该通过它的构造函数将参数穿过去，如果不在参数列表中，则调用默认构造函数</li>
</ul></li>
<li>如果对象支持 virtual 特性，初始化 vptr(s),使之指向正确的 vtable(s)</li>
<li>初始化类类型的成员，如果没在初始化列表中，则调用它的默认构造函数，否则应该为构造函数传递正确的参数</li>
<li>执行函数体内的代码。</li>
</ol>
</div>
</div>

<div id="outline-container-orge189291" class="outline-3">
<h3 id="orge189291">销毁</h3>
<div class="outline-text-3" id="text-orge189291">
<p>
如果类支持 virtual 特性，析构函数会抹销 vptr,析构函数的调用次序与构造函数正好相反：从派生类开始一直到最上层的基类。
</p>
</div>
</div>
</div>
<div id="outline-container-org586fe2f" class="outline-2">
<h2 id="org586fe2f">Member Function</h2>
<div class="outline-text-2" id="text-org586fe2f">
<p>
c++成员函数分为static,non-static,virtual 三种类型，每一种类型的调用方式都不同。
</p>
</div>
<div id="outline-container-org00bb33b" class="outline-3">
<h3 id="org00bb33b">Non-static member function</h3>
<div class="outline-text-3" id="text-org00bb33b">
<p>
C++的涉及准则之一就是non-static member function 至少必须和一般的nonmember function 有相同的效率。编译器会将member
function 内化为nonmember function 形式，步骤如下：
</p>
<ol class="org-ol">
<li>改写函数原型，安插一个额外的参数到参数列表作为第一个参数，用以提供一个存取管道，使函数知道是类的哪个对象在调用它，该
额外参数被称为this 指针，该指针为top-leval const</li>
<li>将每一个“对nonstatic data member的存取操作”改为经由this 指针来存取</li>
<li>将非静态成员函数重新写成一个外部函数，对函数名称进行“mangling”处理，使它在程序中变成独一无二的符号。</li>
</ol>
</div>
</div>
<div id="outline-container-org9da2a81" class="outline-3">
<h3 id="org9da2a81">static member function</h3>
<div class="outline-text-3" id="text-org9da2a81">
<p>
静态成员函数的主要特性是它没有this 指针，以下的次要特性都根源于它的主要特性：
</p>
<ul class="org-ul">
<li>它不能直接存取其class中的non-static members</li>
<li>它不能被声明为const,volatile 或 virtual</li>
<li>它不需要经过class object调用</li>
</ul>
<p>
由于静态成员函数没有this 指针，因此差不多等同于nonmember function.如果取一个static member function 的地址，获得的是其在
内存中的地址,由于static member function 没有this 指针，所以其地址类型不是一个指向class member function 的指针，而是一个
nonmember function 函数指针。
</p>
</div>
</div>
<div id="outline-container-org3b45bd9" class="outline-3">
<h3 id="org3b45bd9">virtual member function</h3>
<div class="outline-text-3" id="text-org3b45bd9">
<p>
虚函数是C++实现多态的一个重要手段，判断一个类能否实现多态（执行期绑定、晚绑定）可以直接观察它有没有虚函数。 <i><span class="underline">在C++中，多
态表示一个以基类的指针或引用来寻址出一个公有派生类对象的意思</span></i>.
</p>
<ul class="org-ul">
<li><a href="stl.html">C++ Standard Libarary</a></li>
<li><a href="class.html">Class</a></li>
<li><a href="names.html">Names And Memory Layout</a></li>
<li><a href="lei.html">Class Usage</a></li>
<li><a href="IO.html">IO lib</a></li>
<li><a href="inheritance.html">inheritance</a></li>
<li><a href="GCC_Clang_Settings.html">Setting GCC and Clang</a></li>
<li><a href="function.html">Function</a></li>
<li><a href="dynamic_memory.html">Dynamic Memory</a></li>
<li><a href="index.html">Index</a></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Tian</p>
<p class="date">Created: 2020-04-15 Wed 11:30</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.0.50 (<a href="https://orgmode.org">Org</a> mode 9.3.6)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
