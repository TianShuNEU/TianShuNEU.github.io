<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-04-13 Mon 23:52 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Function</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/worg.min.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="sitemap.html"> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div><div id="content">
<h1 class="title">Function</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5a1ef22">1. 函数基础</a></li>
<li><a href="#org4e77d10">2. 参数传递</a>
<ul>
<li><a href="#org98766c1">2.1. Passing arguments by value</a></li>
<li><a href="#org1f73971">2.2. Passing arguments by reference</a></li>
<li><a href="#orgf8d308e">2.3. Passing arguments by address</a></li>
<li><a href="#org9f673c2">2.4. Examples</a></li>
</ul>
</li>
<li><a href="#org2c8e66e">3. 结果返回</a>
<ul>
<li><a href="#orgb488d4b">3.1. return by value</a></li>
<li><a href="#orgebedf62">3.2. return by address</a></li>
<li><a href="#orgd6956ab">3.3. return by reference</a></li>
<li><a href="#org6c9da32">3.4. Examples</a></li>
</ul>
</li>
<li><a href="#org3b741f4">4. 函数重载</a>
<ul>
<li><a href="#org5e0d419">4.1. 判断两个形参的类型是否相异</a></li>
<li><a href="#org998e60d">4.2. 内联函数</a></li>
</ul>
</li>
<li><a href="#org1744188">5. 函数指针</a>
<ul>
<li><a href="#org75f9fc9">5.1. 函数指针形参</a></li>
<li><a href="#orgea9be3c">5.2. 返回指向函数的指针</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org5a1ef22" class="outline-2">
<h2 id="org5a1ef22"><span class="section-number-2">1</span> 函数基础</h2>
<div class="outline-text-2" id="text-1">
<p>
函数是一个具名的代码块，我们通过调用函数来执行相应的代码，一个典型的函数包括以下
四部分：返回类型、函数名、形参列表、函数体。在调用函数时我们使用实参初始化形参。
函数在使用之前也需要声明，与变量类似，函数可以声明多次，但只能定义一次，唯一的例
外是虚函数，如果一个函数永远也不会被用到，那么它可以只有声明没有定义。
<code>GOOGLE-STYLE</code> :use snake_case arguments,name function in CamlCase
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-type">void</span> <span class="org-function-name">DoSmth</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">huge_string</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
函数的调用无外乎两个方面，参数传递和结果返回，下面就这两个方面进行详细的解释。
</p>
</div>
</div>
<div id="outline-container-org4e77d10" class="outline-2">
<h2 id="org4e77d10"><span class="section-number-2">2</span> 参数传递</h2>
<div class="outline-text-2" id="text-2">
<p>
每次调用函数时都会重新创建它的形参，并用引入的实参(arguments)对形参(parameters)
进行初始化。形参初始化机理与变量初始化一样。概括的说，一共有3种方式传递参数。
</p>
</div>
<div id="outline-container-org98766c1" class="outline-3">
<h3 id="org98766c1"><span class="section-number-3">2.1</span> Passing arguments by value</h3>
<div class="outline-text-3" id="text-2-1">
<p>
使用这种方式传值时，形参会拷贝实参的值(如果是类类型，则调用复制构造函数),形参与
实参是两个不同的对象，因此在函数中对形参的改变不会影响到实参的值。而此时形参为局部变
量，作用域只有在函数体内有效，当函数返回后所有函数体内定义的局部变量都会被销毁。
<b>Pros and cons of pass by value</b>
</p>

<p>
Advantages of passing by value:
</p>

<ul class="org-ul">
<li>Arguments passed by value can be variables (e.g. x), literals (e.g. 6),
expressions (e.g. x+1), structs &amp; classes, and enumerators. In other
words, just about anything.</li>

<li>Arguments are never changed by the function being called, which prevents
side effects.</li>
</ul>

<p>
Disadvantages of passing by value:
</p>

<ul class="org-ul">
<li>Copying structs and classes can incur a significant performance penalty,
especially if the function is called many times.</li>
</ul>

<p>
When to use pass by value:
</p>

<ul class="org-ul">
<li>When passing fundamental data type and enumerators, and the function does
not need to change the argument.</li>
</ul>

<p>
When not to use pass by value:
</p>

<ul class="org-ul">
<li>When passing structs or classes (including std::array, std::vector, and
std::string).</li>
</ul>

<p>
In most cases, pass by value is the best way to accept parameters of fundamental
types when the function does not need to change the argument. Pass by value is
flexible and safe, and in the case of fundamental types, efficient.
</p>
</div>
</div>
<div id="outline-container-org1f73971" class="outline-3">
<h3 id="org1f73971"><span class="section-number-3">2.2</span> Passing arguments by reference</h3>
<div class="outline-text-3" id="text-2-2">
<p>
以这种方式传递实参可以避免拷贝，形参只是形参的别名，在函数中对形参的操作实际是对
实参的操作，所以如果不希望函数改变实参的话，请加上 <code>const</code> 关键字。我们可以使用
这种传值方式返回多个输出结果。
</p>

<p>
<b>Pros and cons of pass by reference</b>
</p>

<p>
Advantages of passing by reference:
</p>

<ul class="org-ul">
<li>References allow a function to change the value of the argument, which is
sometimes useful. Otherwise, const references can be used to guarantee the
function won’t change the argument.</li>

<li>Because a copy of the argument is not made, pass by reference is fast,
even when used with large structs or classes.</li>

<li>References can be used to return multiple values from a function (via out
parameters).</li>

<li>References must be initialized, so there’s no worry about null values.</li>
</ul>

<p>
Disadvantages of passing by reference:
</p>

<ul class="org-ul">
<li>Because a non-const reference cannot be initialized with an const l-value
or an r-value (e.g. a literal or an expression), arguments to reference
parameters must be normal variables.</li>

<li>It can be hard to tell whether a parameter passed by non-const reference
is meant to be input, output, or both. Judicious use of const and a naming
suffix for out variables can help.</li>

<li>It’s impossible to tell from the function call whether the argument may
change. An argument passed by value and passed by reference looks the
same. We can only tell whether an argument is passed by value or reference
by looking at the function declaration. This can lead to situations where
the programmer does not realize a function will change the value of the
argument.</li>
</ul>


<p>
When to use pass by reference:
</p>

<ul class="org-ul">
<li>When passing structs or classes (use const if read-only).</li>
<li>When you need the function to modify an argument.</li>
<li>When you need access to the type information of a fixed array.</li>
</ul>

<p>
When not to use pass by reference:
</p>

<ul class="org-ul">
<li>When passing fundamental types that don’t need to be modified (use pass by value).</li>
</ul>
</div>
</div>

<div id="outline-container-orgf8d308e" class="outline-3">
<h3 id="orgf8d308e"><span class="section-number-3">2.3</span> Passing arguments by address</h3>
<div class="outline-text-3" id="text-2-3">
<p>
这种传值方式兼具以上两种的特点：形参拷贝实参的值(地址),形参会改变实参指向的对象。
既然发生了拷贝，那么形参与实参是两个不同的变量，形参的变化不影响实参，但是对于它
们指向的对象来说，只是多了一个指向它的指针。函数返回后，形参指针被销毁。
</p>

<p>
我们也可以把形参设计为指针的引用来避免创建新的变量，使得形参与实参为同一个对象。
Pros and cons of pass by address
</p>

<p>
Advantages of passing by address:
</p>

<ul class="org-ul">
<li>Pass by address allows a function to change the value of the argument,
which is sometimes useful. Otherwise, const can be used to guarantee the
function won’t change the argument. (However, if you want to do this with
a non-pointer, you should use pass by reference instead).</li>

<li>Because a copy of the argument is not made, it is fast, even when used
with large structs or classes.</li>

<li>We can return multiple values from a function via out parameters.</li>
</ul>

<p>
Disadvantages of passing by address:
</p>

<ul class="org-ul">
<li>Because literals and expressions do not have addresses, pointer arguments
must be normal variables.</li>

<li>All values must be checked to see whether they are null. Trying to
dereference a null value will result in a crash. It is easy to forget to
do this.</li>

<li>Because dereferencing a pointer is slower than accessing a value directly,
accessing arguments passed by address is slower than accessing arguments
passed by value.</li>
</ul>

<p>
When to use pass by address:
</p>

<ul class="org-ul">
<li>When passing built-in arrays (if you’re okay with the fact that they’ll
decay into a pointer).</li>

<li>When passing a pointer and nullptr is a valid argument logically.</li>
</ul>

<p>
When not to use pass by address:
</p>

<ul class="org-ul">
<li>When passing a pointer and nullptr is not a valid argument logically (use
pass by reference and dereference the pointer argument).</li>

<li>When passing structs or classes (use pass by reference).</li>
<li>When passing fundamental types (use pass by value).</li>
</ul>

<p>
As you can see, pass by address and pass by reference have almost identical
advantages and disadvantages. Because pass by reference is generally safer than
pass by address, pass by reference should be preferred in most cases.
</p>

<p>
<i>Rule: Prefer pass by reference to pass by address whenever applicable.</i>
</p>
</div>
</div>

<div id="outline-container-org9f673c2" class="outline-3">
<h3 id="org9f673c2"><span class="section-number-3">2.4</span> Examples</h3>
<div class="outline-text-3" id="text-2-4">
<p>
当数组作为形参时是需要特别强调的，因为数组不允许拷贝所以不能使用传值传递，因为数
组名会转变为指向头元素的指针，所以当我们为函数传递一个数组时，实际传递的是一个指
针。因此下面三个函数是等价的：
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">int</span>*<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="linenr">2: </span><span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="linenr">3: </span><span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">[</span>10<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-comment-delimiter">//</span><span class="org-comment">&#36825;&#37324;&#30340;&#32500;&#24230;&#26159;&#25105;&#20204;&#26399;&#26395;&#30340;&#65292;&#23454;&#38469;&#19981;&#19968;&#23450;</span>
</pre>
</div>

<p>
因为数组是以指针的形式传递给函数的，因此必须还要向函数提供数组的维度信息，可以使
用如下的方法：
</p>
<ol class="org-ol">
<li>使用标准库规范</li>
</ol>
<p>
使用标准库中的 <code>std::begin()</code> 和 <code>std::end()</code> 获得数组的首迭代器和尾后迭代器，将
这两个迭代器传入函数。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span>  <span class="org-type">int</span> <span class="org-variable-name">j</span><span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]{</span>1,2<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="linenr">2: </span>  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span>* <span class="org-variable-name">beg</span>,<span class="org-type">int</span>*<span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr">3: </span>  <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">4: </span>      <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span>beg != end<span class="org-rainbow-delimiters-depth-2">)</span>
<span class="linenr">5: </span>      <span class="org-rainbow-delimiters-depth-2">{</span>
<span class="linenr">6: </span>          cout &lt;&lt; *beg++ &lt;&lt; endl;
<span class="linenr">7: </span>      <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="linenr">8: </span>  <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">9: </span>print<span class="org-rainbow-delimiters-depth-1">(</span>begin<span class="org-rainbow-delimiters-depth-2">(</span>j<span class="org-rainbow-delimiters-depth-2">)</span>,end<span class="org-rainbow-delimiters-depth-2">(</span>j<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ol class="org-ol">
<li>显式传递一个表示数组大小的形参</li>
</ol>
<p>
在C 程序和过去的C++语言中常用这种方法。
</p>


<p>
下面是一个利用数组的引用避免数组作为形参会退化为指针的例子：
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span class="org-comment-delimiter">// </span><span class="org-comment">Note: You need to specify the array size in the function declaration</span>
<span class="linenr"> 4: </span><span class="org-type">void</span> <span class="org-function-name">printElements</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-2">(</span>&amp;<span class="org-variable-name">arr</span><span class="org-rainbow-delimiters-depth-2">)[</span>4<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr"> 5: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 6: </span>  <span class="org-type">int</span> <span class="org-variable-name">length</span><span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-3">(</span>arr<span class="org-rainbow-delimiters-depth-3">)</span> / <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-3">(</span>arr<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-2">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">we can now do this since the array won't decay</span>
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>  <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-3">{</span> 0 <span class="org-rainbow-delimiters-depth-3">}</span>; i &lt; length; ++i<span class="org-rainbow-delimiters-depth-2">)</span>
<span class="linenr"> 9: </span>  <span class="org-rainbow-delimiters-depth-2">{</span>
<span class="linenr">10: </span>    <span class="org-constant">std</span>::cout &lt;&lt; arr<span class="org-rainbow-delimiters-depth-3">[</span>i<span class="org-rainbow-delimiters-depth-3">]</span> &lt;&lt; <span class="org-string">" "</span>;
<span class="linenr">11: </span>  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="linenr">12: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">13: </span>
<span class="linenr">14: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="linenr">15: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">16: </span>    <span class="org-type">int</span> <span class="org-variable-name">arr</span><span class="org-rainbow-delimiters-depth-2">[]{</span> 99, 20, 14, 80 <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="linenr">17: </span>
<span class="linenr">18: </span>    printElements<span class="org-rainbow-delimiters-depth-2">(</span>arr<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">19: </span>
<span class="linenr">20: </span>    <span class="org-keyword">return</span> 0;
<span class="linenr">21: </span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<pre class="example">
99 20 14 80
</pre>


<p>
上面的例子缺点是只能传递固定维度的数组，如果想要传递任意维度的数组可以使用函数模
板。
<b>传递多维数组</b>
和所有数组一样，当传递多维数组时真正传递的是指向首元素的指针，因为我们传递的是数
组的数组，所以首元素本身就是一个数组，指针就是 <span class="underline">一个指向数组的指针</span> 。数组第二维(以
及后面的所有维)的大小都是数组类型的一部分，不能省略。因此下面的函数是等价的：
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-variable-name">matrix</span><span class="org-rainbow-delimiters-depth-2">)[</span>10<span class="org-rainbow-delimiters-depth-2">]</span>,<span class="org-type">size_t</span> <span class="org-variable-name">row</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="linenr">2: </span><span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">matrix</span><span class="org-rainbow-delimiters-depth-2">[][</span>10<span class="org-rainbow-delimiters-depth-2">]</span>,<span class="org-type">size_t</span> <span class="org-variable-name">row</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org2c8e66e" class="outline-2">
<h2 id="org2c8e66e"><span class="section-number-2">3</span> 结果返回</h2>
<div class="outline-text-2" id="text-3">
<p>
当函数返回调用者处的时候需要调用 <code>return</code> 语句(隐式或显式),无返回值函数在函数最
后会隐式的加上 <code>return;</code> 语句，如果想从函数中间退出，则需要在适当的位置显式调用
<code>return</code>.
以下将重点研究有返回值的函数。
As it turns out, returning values from a function to its caller by value,
address, or reference works almost exactly the same way as passing parameters to
a function does. All of the same upsides and downsides for each method are
present. The primary difference between the two is simply that the direction of
data flow is reversed. However, there is one more added bit of complexity &#x2013;
because local variables in a function go out of scope and are destroyed when the
function returns, we need to consider the effect of this on each return type.
</p>
</div>

<div id="outline-container-orgb488d4b" class="outline-3">
<h3 id="orgb488d4b"><span class="section-number-3">3.1</span> return by value</h3>
<div class="outline-text-3" id="text-3-1">
<p>
When a value is returned by value, a copy of that value is returned to the
caller.
</p>

<p>
When to use return by value:
</p>

<ul class="org-ul">
<li>When returning variables that were declared inside the function</li>
<li>When returning function arguments that were passed by value</li>
</ul>

<p>
When not to use return by value:
</p>

<ul class="org-ul">
<li>When returning a built-in array or pointer (use return by address)</li>
<li>When returning a large struct or class (use return by reference)</li>
</ul>
</div>
</div>

<div id="outline-container-orgebedf62" class="outline-3">
<h3 id="orgebedf62"><span class="section-number-3">3.2</span> return by address</h3>
<div class="outline-text-3" id="text-3-2">
<p>
不可以返回局部变量的地址，因为局部变量在函数返回后就销毁了，因此它原来的地址变成
非法地址，返回这样的地址给调用者再解引用会导致程序出错。
但是如果在函数内部动态申请的内存空间在函数返回后还是有效的，因为动态内存空间值只
能通过程序员使用 <code>delete</code> 或 <code>delete[]</code> 释放。
</p>

<p>
When to use return by address:
</p>

<ul class="org-ul">
<li>When returning dynamically allocated memory</li>
<li>When returning function arguments that were passed by address</li>
</ul>

<p>
When not to use return by address:
</p>

<ul class="org-ul">
<li>When returning variables that were declared inside the function (use return by value)</li>
<li>When returning a large struct or class that was passed by reference (use return by reference)</li>
</ul>
</div>
</div>

<div id="outline-container-orgd6956ab" class="outline-3">
<h3 id="orgd6956ab"><span class="section-number-3">3.3</span> return by reference</h3>
<div class="outline-text-3" id="text-3-3">
<p>
ng oSimilar to pass by address, values returned by reference must be variables (you
should not return a reference to a literal or an expression that resolves to a
temporary value, as those will go out of scope at the end of the function and
you’ll end up returning a dangling reference).When a variable is returned by
reference, a reference to the variable is passed back to the caller. The caller
can then use this reference to continue modifying the variable.
When to use return by reference:
</p>

<ul class="org-ul">
<li>When returning a reference parameter</li>
<li>When returning an element from an array that was passed into the function</li>
<li>When returning a large struct or class that will not be destroyed at the end of the function (e.g. one that was passed in)</li>
</ul>

<p>
When not to use return by reference:
</p>

<ul class="org-ul">
<li>When returning variables that were declared inside the function (use return by value)</li>
<li>When returning a built-in array or pointer value (use return by address)</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-type">int</span> <span class="org-function-name">returnByValue</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="linenr"> 2: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 3: </span>    <span class="org-keyword">return</span> 5;
<span class="linenr"> 4: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span class="org-type">int</span>&amp; <span class="org-function-name">returnByReference</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="linenr"> 7: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 8: </span>     <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">x</span> = 5; <span class="org-comment-delimiter">// </span><span class="org-comment">static ensures x isn't destroyed when the function ends</span>
<span class="linenr"> 9: </span>     <span class="org-keyword">return</span> x;
<span class="linenr">10: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">11: </span>
<span class="linenr">12: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="linenr">13: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">14: </span>    <span class="org-type">int</span> <span class="org-variable-name">value</span> = returnByReference<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">case A -- ok, treated as return by value</span>
<span class="linenr">15: </span>    <span class="org-type">int</span> &amp;<span class="org-variable-name">ref</span> = returnByValue<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">case B -- compile error since the value is an r-value, and an r-value can't bind to a non-const reference</span>
<span class="linenr">16: </span>    <span class="org-keyword">const</span> <span class="org-type">int</span> &amp;<span class="org-variable-name">cref</span> = returnByValue<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">case C -- ok, the lifetime of the return value is extended to the lifetime of cref</span>
<span class="linenr">17: </span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org6c9da32" class="outline-3">
<h3 id="org6c9da32"><span class="section-number-3">3.4</span> Examples</h3>
<div class="outline-text-3" id="text-3-4">
<p>
返回数组指针
因为数组不能拷贝，因此不能直接返回数组，需要返回数组的指针或引用.回想一下我们如
何声明指向数组的指针：
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-type">int</span> <span class="org-variable-name">arr</span><span class="org-rainbow-delimiters-depth-1">[</span>10<span class="org-rainbow-delimiters-depth-1">]{</span>0<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="linenr">2: </span><span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-1">(</span>*<span class="org-variable-name">parr</span><span class="org-rainbow-delimiters-depth-1">)[</span>10<span class="org-rainbow-delimiters-depth-1">]</span> = &amp;arr; <span class="org-comment-delimiter">//</span><span class="org-comment">parr &#26159;&#25351;&#21521;&#19968;&#20010;&#20855;&#26377;10&#20010;&#25972;&#22411;&#20803;&#32032;&#30340;&#25351;&#38024;&#65292; *parr &#20004;&#36793;&#30340;&#22278;&#25324;&#21495;&#24517;&#19981;&#21487;&#23569;</span>
</pre>
</div>

<p>
与声明一个指向数组的指针变量类似，我们声明一个返回数组的指针或引用的函数采用如下
的形式：
</p>
<pre class="example">
Type (*function(parameter_list)) [dimension];
Type (&amp;function(parameter_list)) [dimension];
</pre>

<p>
可以看到，我们用函数的名字和形参列表替代了原来指针名称的位置，比如：
</p>
<pre class="example">
int (*func(int i)) [10];
</pre>

<p>
我们声明了一个函数，我们可以按照下面的顺序逐层理解该声明的含义：
</p>
<ul class="org-ul">
<li><code>func(int i)</code> 表示调用函数时需要一个整型实参</li>
<li><code>*func(int i)</code> 表示我们可以对函数调用的结果执行解引用</li>
<li><code>(*func(int i))[10]</code> 表示解引用函数调用将得到一个大小为10的数组</li>
<li><code>int (*func(int i))[10]</code> 表示数组的元素是 <code>int</code> 类型</li>
</ul>
<p>
这是直接定义了一个返回数组指针的方法，这种方法写起来比较麻烦，我们有以下几种办法
来简化这一任务。
</p>
<dl class="org-dl">
<dt>使用类型别名</dt><dd>这是最常用的方法。比如上面的例子可以简化为：</dd>
</dl>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-keyword">typedef</span> <span class="org-type">int</span> <span class="org-type">arrT</span><span class="org-rainbow-delimiters-depth-1">[</span>10<span class="org-rainbow-delimiters-depth-1">]</span> ;
<span class="linenr">2: </span><span class="org-comment-delimiter">// </span><span class="org-comment">using arrT = int[10]; //arrT &#30340;&#31561;&#20215;&#22768;&#26126;</span>
<span class="linenr">3: </span><span class="org-type">arrT</span>* <span class="org-function-name">func</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<dl class="org-dl">
<dt>使用尾置返回类型</dt><dd>这是C++11的新特性，任何函数都可以使用尾置返回(trailing
return type),但是用在返回类型复杂的函数上最有效。使用方法是在原来
返回类型的地方放置一个 <code>auto</code>, 真正的返回类型跟在形参列表后面并且
以 <code>-&gt;</code> 开头。</dd>
</dl>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-keyword">auto</span> <span class="org-function-name">func</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">(</span>*<span class="org-rainbow-delimiters-depth-1">)[</span>10<span class="org-rainbow-delimiters-depth-1">]</span>;
</pre>
</div>

<dl class="org-dl">
<dt>使用decltype</dt><dd>如果我们知道函数返回的指针将指向哪个数组，就可以使用
<code>decltype</code> 关键字获取返回类型</dd>
</dl>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-type">int</span> <span class="org-variable-name">odd</span><span class="org-rainbow-delimiters-depth-1">[]{</span>1,3,5,7,9<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="linenr">2: </span><span class="org-type">int</span> <span class="org-variable-name">even</span><span class="org-rainbow-delimiters-depth-1">[]{</span>2,4,6,8,0<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="linenr">3: </span><span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-1">(</span>odd<span class="org-rainbow-delimiters-depth-1">)</span> *<span class="org-function-name">arrPtr</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr">4: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">5: </span>    <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span>i%2<span class="org-rainbow-delimiters-depth-2">)</span>?&amp;odd:&amp;even;
<span class="linenr">6: </span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3b741f4" class="outline-2">
<h2 id="org3b741f4"><span class="section-number-2">4</span> 函数重载</h2>
<div class="outline-text-2" id="text-4">
<p>
函数重载是C++的一个特性，这个特性使得我们可以使用一个函数名创建多个函数，只要它
们的形参列表不同，而我们并不能将返回类型作为区分函数重载的依据（Put another way,
we can always determine which version of a function will be called based solely
on the arguments. If return values were included, then we wouldn’t have an easy
syntactic way to tell which version of a function was being called）
</p>
</div>

<div id="outline-container-org5e0d419" class="outline-3">
<h3 id="org5e0d419"><span class="section-number-3">4.1</span> 判断两个形参的类型是否相异</h3>
<div class="outline-text-3" id="text-4-1">
<dl class="org-dl">
<dt>类型别名</dt><dd>别名不能引入一个新的类型，因此别名不能作为重载函数</dd>
<dt>const形参</dt><dd>顶层const 不影响传入函数的对象，一个拥有顶层const 的形参无法与另一
个没有顶层const 的形参区分开，而一个拥有底层const 的形参可以与另一个没有底层
           const 的形参区分开。</dd>
</dl>
</div>
</div>

<div id="outline-container-org998e60d" class="outline-3">
<h3 id="org998e60d"><span class="section-number-3">4.2</span> 内联函数</h3>
<div class="outline-text-3" id="text-4-2">
<p>
我们可以将一些代码较小的函数声明尾内联函数，只要在函数最前面加上 <code>inline</code> 即可，
内联函数可以避免普通函数在调用时的开销，比如调用前要先保存寄存器并在返回时恢复，
可能需要拷贝实参，程序转向一个新的位置继续执行等。编译器可以选择忽略我们将一个函
数作为一个内联函数使用。编译器不会去编译内联函数，而只是将它在每个调用点上“内联”
的展开，因此内联函数可以定义在头文件中。Inline functions are exempt
from the rule that you can only have one definition per program, because of the
fact that inline functions do not actually result in a real function being
compiled &#x2013; therefore, there’s no conflict when the linker goes to link multiple
files together.
</p>
</div>
</div>
</div>

<div id="outline-container-org1744188" class="outline-2">
<h2 id="org1744188"><span class="section-number-2">5</span> 函数指针</h2>
<div class="outline-text-2" id="text-5">
<p>
由于函数在程序内存中也是有地址的，因此我们可以定义函数指针指向函数。 <b>函数的类型由
它的返回类型和形参类型共同决定，与函数名无关</b>  在指向不同函数类型的指针间不存在转
换规则，但是当函数指针不指向任何函数时我们可以给它赋值 <code>nullptr</code>.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 2: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 3: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">//</span><span class="org-comment">std::function</span>
<span class="linenr"> 4: </span><span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">str</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr"> 5: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 6: </span>    <span class="org-constant">std</span>::cout &lt;&lt; str &lt;&lt; <span class="org-string">"\n"</span>;
<span class="linenr"> 7: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span class="org-comment-delimiter">//</span><span class="org-comment">1 &#30452;&#25509;&#20351;&#29992;&#20989;&#25968;&#31867;&#22411;&#23450;&#20041;&#20989;&#25968;&#25351;&#38024;</span>
<span class="linenr">10: </span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-1">(</span>*<span class="org-function-name">pf</span><span class="org-rainbow-delimiters-depth-1">)(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp;<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="linenr">11: </span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-1">(</span>*<span class="org-keyword">const</span> <span class="org-function-name">cpf</span><span class="org-rainbow-delimiters-depth-1">)(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp;<span class="org-rainbow-delimiters-depth-1">)</span> = print;
<span class="linenr">12: </span>
<span class="linenr">13: </span><span class="org-comment-delimiter">//</span><span class="org-comment">2 &#20026;&#20989;&#25968;&#31867;&#22411;&#21462;&#21035;&#21517;&#65292;&#21487;&#20197;&#30452;&#25509;&#29992;&#21035;&#21517;&#23450;&#20041;&#20989;&#25968;&#25351;&#38024;&#65292;&#24182;&#25351;&#21521;&#27491;&#30830;&#30340;&#20989;&#25968;&#65292;&#26041;&#20415;&#20070;&#20889;&#21644;&#29702;&#35299;</span>
<span class="linenr">14: </span><span class="org-comment-delimiter">//</span><span class="org-comment">2.1 &#33719;&#24471;&#20989;&#25968;&#25351;&#38024;&#65292; PT&#26159;&#19968;&#20010;&#25351;&#21521;&#20989;&#25968;&#30340;&#25351;&#38024;</span>
<span class="linenr">15: </span><span class="org-comment-delimiter">// </span><span class="org-comment">typedef void (*PT) (const std::string&amp; str);</span>
<span class="linenr">16: </span><span class="org-comment-delimiter">// </span><span class="org-comment">using PT = void (*)(const std::string&amp;);</span>
<span class="linenr">17: </span><span class="org-comment-delimiter">//</span><span class="org-comment">2.2 &#33719;&#24471;&#20989;&#25968;&#31867;&#22411;&#65292; P &#26159;&#19968;&#20010;&#20989;&#25968;&#31867;&#22411;</span>
<span class="linenr">18: </span><span class="org-comment-delimiter">//  </span><span class="org-comment">typedef void P(const std::string&amp;);</span>
<span class="linenr">19: </span><span class="org-comment-delimiter">//  </span><span class="org-comment">using P = void(const std::string&amp;);</span>
<span class="linenr">20: </span><span class="org-comment-delimiter">//</span><span class="org-comment">3 &#36890;&#36807;decltype&#20851;&#38190;&#23383;&#33719;&#21462;&#20989;&#25968;&#31867;&#22411;&#65292;&#24182;&#20026;&#20854;&#21462;&#21035;&#21517;</span>
<span class="linenr">21: </span><span class="org-comment-delimiter">// </span><span class="org-comment">typedef decltype(print) *PT;</span>
<span class="linenr">22: </span><span class="org-keyword">using</span> <span class="org-type">PT</span> = <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-1">(</span>print<span class="org-rainbow-delimiters-depth-1">)</span>*;
<span class="linenr">23: </span>
<span class="linenr">24: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr">25: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">26: </span>    cpf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"This is cpf!"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">27: </span>    pf = print;
<span class="linenr">28: </span>    pf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"This is pf!"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">29: </span>    <span class="org-type">PT</span> <span class="org-variable-name">pt</span>;
<span class="linenr">30: </span>    pt = print;
<span class="linenr">31: </span>    pt<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"THis is pt"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">32: </span><span class="org-comment-delimiter">//</span><span class="org-comment">&#30452;&#25509;&#20351;&#29992;decltype &#23450;&#20041;&#20989;&#25968;&#25351;&#38024;</span>
<span class="linenr">33: </span>    <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-2">(</span>print<span class="org-rainbow-delimiters-depth-2">)</span> *<span class="org-variable-name">dpt</span>;
<span class="linenr">34: </span>    dpt = print;
<span class="linenr">35: </span>    dpt<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"THis is dpt!"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">36: </span><span class="org-comment-delimiter">//</span><span class="org-comment">&#20351;&#29992;std::function</span>
<span class="linenr">37: </span>    <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp;<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">fpf</span>;
<span class="linenr">38: </span>    fpf = print;
<span class="linenr">39: </span>    fpf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"This is fpf!"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">40: </span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<pre class="example">
This is cpf!
This is pf!
THis is pt
THis is dpt!
This is fpf!
</pre>

<p>
函数 <code>print</code> 的类型是 <code>void(const std::string&amp;)</code>,类似于普通的数据类型，比如 <code>double</code>,
对于这样一个简单的函数，每次写函数类型还是可以接受的，毕竟不算太麻烦，但如果一个
具有复杂返回类型和形参列表的函数，每次都写完整的类型不仅写起来麻烦，而且不容易理
解，最重要的是很容易出错，因此我们可以用以下方法来简化函数类型：
</p>
<dl class="org-dl">
<dt>类型别名</dt><dd>使用 <code>typedef</code> 或者 <code>using</code> 来为函数类型取别名。</dd>
<dt>decltype</dt><dd>在C++11中可以使用 <code>decltype</code> 关键字获取某个函数的类型。</dd>
<dt>std::function</dt><dd>在C++11中还可以使用 <code>std::function</code> 方法来定义和存储函数指针</dd>
</dl>
</div>
<div id="outline-container-org75f9fc9" class="outline-3">
<h3 id="org75f9fc9"><span class="section-number-3">5.1</span> 函数指针形参</h3>
<div class="outline-text-3" id="text-5-1">
<p>
我们应该在心理有这样一个概念，将函数与对象对应起来：函数类型对应数据类型，函数名
对应对象名。既然我们能把数据类型作为函数形参，那么也能把函数类型作为另一个函数的
形参，我们把这样的函数叫做回调函数 (callback funciton).函数指针形参也可以有默认
值。下面以一个排序算法的改进来说明回调函数的用法：
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">algorithm</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">for std::swap, use &lt;utility&gt; instead if C++11</span>
<span class="linenr"> 2: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 3: </span><span class="org-type">void</span> <span class="org-function-name">SelectionSort</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> *<span class="org-variable-name">array</span>, <span class="org-type">int</span> <span class="org-variable-name">size</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr"> 4: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 5: </span>    <span class="org-comment-delimiter">// </span><span class="org-comment">Step through each element of the array</span>
<span class="linenr"> 6: </span>    <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">startIndex</span> = 0; startIndex &lt; size; ++startIndex<span class="org-rainbow-delimiters-depth-2">)</span>
<span class="linenr"> 7: </span>    <span class="org-rainbow-delimiters-depth-2">{</span>
<span class="linenr"> 8: </span>        <span class="org-comment-delimiter">// </span><span class="org-comment">smallestIndex is the index of the smallest element we've encountered so far.</span>
<span class="linenr"> 9: </span>        <span class="org-type">int</span> <span class="org-variable-name">smallestIndex</span> = startIndex;
<span class="linenr">10: </span>
<span class="linenr">11: </span>        <span class="org-comment-delimiter">// </span><span class="org-comment">Look for smallest element remaining in the array (starting at startIndex+1)</span>
<span class="linenr">12: </span>        <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">int</span> <span class="org-variable-name">currentIndex</span> = startIndex + 1; currentIndex &lt; size; ++currentIndex<span class="org-rainbow-delimiters-depth-3">)</span>
<span class="linenr">13: </span>        <span class="org-rainbow-delimiters-depth-3">{</span>
<span class="linenr">14: </span>            <span class="org-comment-delimiter">// </span><span class="org-comment">If the current element is smaller than our previously found smallest</span>
<span class="linenr">15: </span>            <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>array<span class="org-rainbow-delimiters-depth-5">[</span>smallestIndex<span class="org-rainbow-delimiters-depth-5">]</span> &gt; array<span class="org-rainbow-delimiters-depth-5">[</span>currentIndex<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-comment-delimiter">// </span><span class="org-comment">COMPARISON </span><span class="custom">DONE</span><span class="org-comment"> HERE</span>
<span class="linenr">16: </span>                <span class="org-comment-delimiter">// </span><span class="org-comment">This is the new smallest number for this iteration</span>
<span class="linenr">17: </span>                smallestIndex = currentIndex;
<span class="linenr">18: </span>        <span class="org-rainbow-delimiters-depth-3">}</span>
<span class="linenr">19: </span>
<span class="linenr">20: </span>        <span class="org-comment-delimiter">// </span><span class="org-comment">Swap our start element with our smallest element</span>
<span class="linenr">21: </span>        <span class="org-constant">std</span>::swap<span class="org-rainbow-delimiters-depth-3">(</span>array<span class="org-rainbow-delimiters-depth-4">[</span>startIndex<span class="org-rainbow-delimiters-depth-4">]</span>, array<span class="org-rainbow-delimiters-depth-4">[</span>smallestIndex<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span>;
<span class="linenr">22: </span>    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="linenr">23: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">24: </span><span class="org-comment-delimiter">// </span><span class="org-comment">This function prints out the values in the array</span>
<span class="linenr">25: </span><span class="org-type">void</span> <span class="org-function-name">printArray</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> *<span class="org-variable-name">array</span>, <span class="org-type">int</span> <span class="org-variable-name">size</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr">26: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">27: </span>    <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">index</span>=0; index &lt; size; ++index<span class="org-rainbow-delimiters-depth-2">)</span>
<span class="linenr">28: </span>        <span class="org-constant">std</span>::cout &lt;&lt; array<span class="org-rainbow-delimiters-depth-2">[</span>index<span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; <span class="org-string">" "</span>;
<span class="linenr">29: </span>    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">'\n'</span>;
<span class="linenr">30: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">31: </span>
<span class="linenr">32: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr">33: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">34: </span>    <span class="org-type">int</span> <span class="org-variable-name">array</span><span class="org-rainbow-delimiters-depth-2">[</span>9<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-rainbow-delimiters-depth-2">{</span> 3, 7, 9, 5, 6, 1, 8, 2, 4 <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="linenr">35: </span>    SelectionSort<span class="org-rainbow-delimiters-depth-2">(</span>array, 9<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">36: </span>    printArray<span class="org-rainbow-delimiters-depth-2">(</span>array,9<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">37: </span>    <span class="org-keyword">return</span> 0;
<span class="linenr">38: </span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<pre class="example">
1 2 3 4 5 6 7 8 9
</pre>

<p>
本例的 <code>SelectionSort</code> 函数只有一个功能，就是按递增的方式对数组排序，如果我们想
要一个按递减方式对数组排序的函数那就只能重新写一个递减的版本，当我们使用了函数指
针以后，我们可以不必重新写 <code>SelectionSort</code> 函数，而只要改变比较的方式即可。思路
就是写一个比较函数(递增或递减),然后将比较函数传入 <code>SelectionSort</code>,替换掉原函数中
的比较语句，这样我们就可以使用自己版本的比较函数，我们甚至还可以写更多的比较函数
传入排序函数中，这样大大增大了代码的灵活性和可重用性。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">algorithm</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">for std::swap, use &lt;utility&gt; instead if C++11</span>
<span class="linenr"> 2: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span class="org-comment-delimiter">// </span><span class="org-comment">Note our user-defined comparison is the third parameter</span>
<span class="linenr"> 5: </span><span class="org-type">void</span> <span class="org-function-name">selectionSort</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> *<span class="org-variable-name">array</span>, <span class="org-type">int</span> <span class="org-variable-name">size</span>, <span class="org-type">bool</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-function-name">comparisonFcn</span><span class="org-rainbow-delimiters-depth-2">)(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr"> 6: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 7: </span>    <span class="org-comment-delimiter">// </span><span class="org-comment">Step through each element of the array</span>
<span class="linenr"> 8: </span>    <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">startIndex</span> = 0; startIndex &lt; size; ++startIndex<span class="org-rainbow-delimiters-depth-2">)</span>
<span class="linenr"> 9: </span>    <span class="org-rainbow-delimiters-depth-2">{</span>
<span class="linenr">10: </span>        <span class="org-comment-delimiter">// </span><span class="org-comment">bestIndex is the index of the smallest/largest element we've encountered so far.</span>
<span class="linenr">11: </span>        <span class="org-type">int</span> <span class="org-variable-name">bestIndex</span> = startIndex;
<span class="linenr">12: </span>
<span class="linenr">13: </span>        <span class="org-comment-delimiter">// </span><span class="org-comment">Look for smallest/largest element remaining in the array (starting at startIndex+1)</span>
<span class="linenr">14: </span>        <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">int</span> <span class="org-variable-name">currentIndex</span> = startIndex + 1; currentIndex &lt; size; ++currentIndex<span class="org-rainbow-delimiters-depth-3">)</span>
<span class="linenr">15: </span>        <span class="org-rainbow-delimiters-depth-3">{</span>
<span class="linenr">16: </span>            <span class="org-comment-delimiter">// </span><span class="org-comment">If the current element is smaller/larger than our previously found smallest</span>
<span class="linenr">17: </span>            <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>comparisonFcn<span class="org-rainbow-delimiters-depth-5">(</span>array<span class="org-rainbow-delimiters-depth-6">[</span>bestIndex<span class="org-rainbow-delimiters-depth-6">]</span>, array<span class="org-rainbow-delimiters-depth-6">[</span>currentIndex<span class="org-rainbow-delimiters-depth-6">]</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-comment-delimiter">// </span><span class="org-comment">COMPARISON </span><span class="custom">DONE</span><span class="org-comment"> HERE</span>
<span class="linenr">18: </span>                <span class="org-comment-delimiter">// </span><span class="org-comment">This is the new smallest/largest number for this iteration</span>
<span class="linenr">19: </span>                bestIndex = currentIndex;
<span class="linenr">20: </span>        <span class="org-rainbow-delimiters-depth-3">}</span>
<span class="linenr">21: </span>
<span class="linenr">22: </span>        <span class="org-comment-delimiter">// </span><span class="org-comment">Swap our start element with our smallest/largest element</span>
<span class="linenr">23: </span>        <span class="org-constant">std</span>::swap<span class="org-rainbow-delimiters-depth-3">(</span>array<span class="org-rainbow-delimiters-depth-4">[</span>startIndex<span class="org-rainbow-delimiters-depth-4">]</span>, array<span class="org-rainbow-delimiters-depth-4">[</span>bestIndex<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span>;
<span class="linenr">24: </span>    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="linenr">25: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">26: </span>
<span class="linenr">27: </span><span class="org-comment-delimiter">// </span><span class="org-comment">Here is a comparison function that sorts in ascending order</span>
<span class="linenr">28: </span><span class="org-comment-delimiter">// </span><span class="org-comment">(Note: it's exactly the same as the previous ascending() function)</span>
<span class="linenr">29: </span><span class="org-type">bool</span> <span class="org-function-name">ascending</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr">30: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">31: </span>    <span class="org-keyword">return</span> x &gt; y; <span class="org-comment-delimiter">// </span><span class="org-comment">swap if the first element is greater than the second</span>
<span class="linenr">32: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">33: </span>
<span class="linenr">34: </span><span class="org-comment-delimiter">// </span><span class="org-comment">Here is a comparison function that sorts in descending order</span>
<span class="linenr">35: </span><span class="org-type">bool</span> <span class="org-function-name">descending</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr">36: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">37: </span>    <span class="org-keyword">return</span> x &lt; y; <span class="org-comment-delimiter">// </span><span class="org-comment">swap if the second element is greater than the first</span>
<span class="linenr">38: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">39: </span>
<span class="linenr">40: </span><span class="org-comment-delimiter">// </span><span class="org-comment">This function prints out the values in the array</span>
<span class="linenr">41: </span><span class="org-type">void</span> <span class="org-function-name">printArray</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> *<span class="org-variable-name">array</span>, <span class="org-type">int</span> <span class="org-variable-name">size</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr">42: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">43: </span>    <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">index</span>=0; index &lt; size; ++index<span class="org-rainbow-delimiters-depth-2">)</span>
<span class="linenr">44: </span>        <span class="org-constant">std</span>::cout &lt;&lt; array<span class="org-rainbow-delimiters-depth-2">[</span>index<span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; <span class="org-string">" "</span>;
<span class="linenr">45: </span>    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">'\n'</span>;
<span class="linenr">46: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">47: </span>
<span class="linenr">48: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="linenr">49: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">50: </span>    <span class="org-type">int</span> <span class="org-variable-name">array</span><span class="org-rainbow-delimiters-depth-2">[</span>9<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-rainbow-delimiters-depth-2">{</span> 3, 7, 9, 5, 6, 1, 8, 2, 4 <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="linenr">51: </span>
<span class="linenr">52: </span>    <span class="org-comment-delimiter">// </span><span class="org-comment">Sort the array in descending order using the descending() function</span>
<span class="linenr">53: </span>    selectionSort<span class="org-rainbow-delimiters-depth-2">(</span>array, 9, descending<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">54: </span>    printArray<span class="org-rainbow-delimiters-depth-2">(</span>array, 9<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">55: </span>
<span class="linenr">56: </span>    <span class="org-comment-delimiter">// </span><span class="org-comment">Sort the array in ascending order using the ascending() function</span>
<span class="linenr">57: </span>    selectionSort<span class="org-rainbow-delimiters-depth-2">(</span>array, 9, ascending<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">58: </span>    printArray<span class="org-rainbow-delimiters-depth-2">(</span>array, 9<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">59: </span>
<span class="linenr">60: </span>    <span class="org-keyword">return</span> 0;
<span class="linenr">61: </span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<pre class="example">
9 8 7 6 5 4 3 2 1
1 2 3 4 5 6 7 8 9
</pre>
</div>
</div>

<div id="outline-container-orgea9be3c" class="outline-3">
<h3 id="orgea9be3c"><span class="section-number-3">5.2</span> 返回指向函数的指针</h3>
<div class="outline-text-3" id="text-5-2">
<p>
和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。参照下面的例子：
</p>
<pre class="example">
int (*fun(int)) (int*,double);
</pre>

<p>
从里往外看：首先 <code>fun</code> 有形参列表，所以它是一个函数，它前面有‘*’，说明返回类型是
个指针，再看右边，指针本身也包含形参列表，因此该指针指向一个函数，该函数的返回值
是整型。以上声明与下面的等价：
</p>
<pre class="example">
auto fun(int) -&gt; int(*)(int*,double);
</pre>

<p>
或者使用别名：
</p>
<pre class="example">
using PF = int(*)(int*,double);
PF fun(int);
</pre>

<p>
或者使用 <code>decltype</code>:
</p>
<pre class="example">
int demo(int*,double);
decltype(demo) *fun(int);
</pre>

<ul class="org-ul">
<li><a href="stl.html">C++ Standard Libarary</a></li>
<li><a href="names.html">Names And Memory Layout</a></li>
<li><a href="lei.html">Class Usage</a></li>
<li><a href="IO.html">IO lib</a></li>
<li><a href="inheritance.html">inheritance</a></li>
<li><a href="GCC_Clang_Settings.html">Setting GCC and Clang</a></li>
<li><a href="function.html">Function</a></li>
<li><a href="dynamic_memory.html">Dynamic Memory</a></li>
<li><a href="class.html">Class</a></li>
<li><a href="index.html">Index</a></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2018-11-21</p>
<p class="date">Created: 2020-04-13 Mon 23:52</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.0.50 (<a href="https://orgmode.org">Org</a> mode 9.3.6)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
