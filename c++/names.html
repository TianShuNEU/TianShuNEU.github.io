<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-04-11 Sat 23:07 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Names And Memory Layout</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Tian Tongtong" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/worg.min.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="sitemap.html"> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div><div id="content">
<h1 class="title">Names And Memory Layout</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgcada2ea">概述</a></li>
<li><a href="#orgf062d07">变量和基本类型</a>
<ul>
<li><a href="#orgcf5132e">基本类型</a></li>
<li><a href="#org86a9d29">变量</a>
<ul>
<li><a href="#org291bf40">声明与定义</a></li>
<li><a href="#org2ed540d">变量初始化与赋值</a></li>
</ul>
</li>
<li><a href="#org6ff13f0">复合类型</a>
<ul>
<li><a href="#org77b98bd">引用 (reference)</a></li>
<li><a href="#orga4ee287">指针</a></li>
</ul>
</li>
<li><a href="#org9187d76">const 限定符</a>
<ul>
<li><a href="#org9daa08c">compile time VS runtime</a></li>
<li><a href="#org1ad9178">const VS constexpr</a></li>
<li><a href="#org8500cf2">top-level const VS low-level const</a></li>
<li><a href="#org8bd4d83">constexpr 与 指针</a></li>
</ul>
</li>
<li><a href="#org6d76535">处理类型</a>
<ul>
<li><a href="#org6294b5e">类型别名</a></li>
<li><a href="#org1a4fb87">auto 类型说明符</a></li>
<li><a href="#org7a72612">decltype类型指示符</a></li>
</ul>
</li>
<li><a href="#org6326de2">内置数组</a>
<ul>
<li><a href="#org9e36925">数组的定义和初始化</a></li>
<li><a href="#orgf4e9ff3">理解复杂的数组声明</a></li>
<li><a href="#orgcba3034">访问数组元素</a></li>
<li><a href="#orgde5dbc3">数组与指针</a></li>
<li><a href="#org1795da5">动态数组</a></li>
<li><a href="#org3d520da">多维数组</a></li>
</ul>
</li>
<li><a href="#org90cb3d3">枚举类型</a>
<ul>
<li><a href="#org20dd519">枚举成员</a></li>
<li><a href="#org661778d">前置声明</a></li>
<li><a href="#org0bc58a1">形参匹配</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6d2671b">名字的作用域、生存期、链接性</a></li>
<li><a href="#org532d774">命名空间</a>
<ul>
<li><a href="#orgf006788">内联命名空间</a></li>
<li><a href="#org0a05bec">未命名的命名空间</a></li>
<li><a href="#org5d81146">命名空间别名</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
本系列是我学习C++的一个记录，主要参考《Primer C++(5th)》和《深入理解计算机系统
（3th）》，目标是不仅要知道C++的语法规则，并且尽量探究在這些规则背后的原理。做到
知道其所以然才能知其然。
</p>
<div id="outline-container-orgcada2ea" class="outline-2">
<h2 id="orgcada2ea">概述</h2>
<div class="outline-text-2" id="text-orgcada2ea">
<p>
名字(name)包含变量名和函数名，C++中名字都要与数据类型(data type)绑定，C++是静态
类型检查语言，即在编译时就必须检查数据类型。
</p>
</div>
</div>
<div id="outline-container-orgf062d07" class="outline-2">
<h2 id="orgf062d07">变量和基本类型</h2>
<div class="outline-text-2" id="text-orgf062d07">
<p>
数据类型时程序的基础，它告诉我们数据的意义和我们能在实际上能够执行的操作。
</p>
</div>
<div id="outline-container-orgcf5132e" class="outline-3">
<h3 id="orgcf5132e">基本类型</h3>
<div class="outline-text-3" id="text-orgcf5132e">
<p>
C++定义了一套包括算术类型(arithmetic type)和空类型(void)在内的基本数据类型。
</p>
</div>
</div>
<div id="outline-container-org86a9d29" class="outline-3">
<h3 id="org86a9d29">变量</h3>
<div class="outline-text-3" id="text-org86a9d29">
<p>
变量提供一个具名的、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据
类型决定了变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能进
行的运算。
</p>
</div>
<div id="outline-container-org291bf40" class="outline-4">
<h4 id="org291bf40">声明与定义</h4>
<div class="outline-text-4" id="text-org291bf40">
<dl class="org-dl">
<dt>变量定义</dt><dd>定义变量不仅规定了变量的类型和名字，还为这个变量申请存储空间，可以显式或隐式的为变量赋初值，
这叫做变量的初始化。变量能且只能被定义一次。形式： <i>{extern}type
var{=init_val}</i></dd>
<dt>变量声明</dt><dd>变量声明规定了变量的类型和名字，变量可以被声明多次。形式： <i>extern
type var</i></dd>
</dl>
<p>
变量的定义和声明区分开来是为了支持分离式编译，一个名字(包括变量和函数)可以在适当
的源文件(.cpp)中定义，如果想要在别的文件中使用它们，就必须在使用前声明它们，好让
程序知道名字的一切信息（包括变量的类型、函数的参数类型和返回类型），编译系统会使
用链接器链接名字的声明与定义。名字的声明通常都在头文件中，名字的定义通常在源文件。
</p>
</div>
</div>
<div id="outline-container-org2ed540d" class="outline-4">
<h4 id="org2ed540d">变量初始化与赋值</h4>
<div class="outline-text-4" id="text-org2ed540d">
<dl class="org-dl">
<dt>初始化</dt><dd>当对象在被创建时获得了一个特定值(初始值)。</dd>
<dt>赋值</dt><dd>在使用变量时擦除其当前值并以一个新值代替。</dd>
</dl>
<p>
C++有三种初始化变量的方式：
</p>
<dl class="org-dl">
<dt>copy initialization</dt><dd>使用‘＝’符号，形式： <i>int nValue = 8;</i></dd>
<dt>direct initialization</dt><dd>使用‘()’符号，形式： <i>int nValue(8);</i> 尽管这种初始化
方式看起来像是函数调用，但是编译器会追踪哪些名称是变量，哪些是函数，因此這
些名字能够被正确解析。</dd>
<dt>uniform initialization</dt><dd>使用‘{}’符号，前两种初始化方式在有些情况下不能用，比
如初始化容器。在C++11中可以使用这种方式进行初始化，但是要注意在初始化内置类
型时，如果初始值存在丢失信息的风险，则编译器会报错。形式： <i>int a{0};</i></dd>
</dl>
<p>
<b>Note</b>: 如果你在使用C++11,你应该优先使用列表初始化方式。
</p>
</div>
</div>
</div>
<div id="outline-container-org6ff13f0" class="outline-3">
<h3 id="org6ff13f0">复合类型</h3>
<div class="outline-text-3" id="text-org6ff13f0">
<p>
复合类型是基于其它类型定义的类型，C++有几种复合类型，这里介绍其中两种：引用和指
针。
</p>
</div>
<div id="outline-container-org77b98bd" class="outline-4">
<h4 id="org77b98bd">引用 (reference)</h4>
<div class="outline-text-4" id="text-org77b98bd">
<p>
引用是为对象起了另一个名字。在定义引用时，程序把引用和它的初始值绑定在一起，而不
是将初始值拷贝给引用，一旦初始化完成，引用将和它的初始值对象绑定在一起，无法再重
新绑定另一个对象，因此，引用必须初始化。一个引用与它所绑定的对象的类型必须匹配。
</p>
</div>
</div>
<div id="outline-container-orga4ee287" class="outline-4">
<h4 id="orga4ee287">指针</h4>
<div class="outline-text-4" id="text-orga4ee287">
<p>
指针指向一个对象，指针本身是一个对象，它提供了对所指向对象的简介访问，可以重新指
向一个新的对象，指针与它所指向的对象的类型也必须一致。
指针的值：
</p>
<dl class="org-dl">
<dt>指向一个对象</dt><dd>此时指针的值为该对象的地址，地址由取地址符&amp;获得。</dd>
<dt>指向紧邻对象所占空间的下一位置</dt><dd></dd>

<dt>空指针</dt><dd>没有指向任何对象，值为 <code>nullptr</code></dd>
<dt>无效指针</dt><dd>上述情况情况的其它值</dd>
</dl>
<p>
利用指针访问对象：
</p>
<dl class="org-dl">
<dt>只有当指针指向一个对象时</dt><dd>使用解引用符(*)来访问该对象。</dd>
</dl>
</div>
</div>
</div>
<div id="outline-container-org9187d76" class="outline-3">
<h3 id="org9187d76">const 限定符</h3>
<div class="outline-text-3" id="text-org9187d76">
</div>
<div id="outline-container-org9daa08c" class="outline-4">
<h4 id="org9daa08c">compile time VS runtime</h4>
<div class="outline-text-4" id="text-org9daa08c">
<p>
当你在编译程序的时候，叫做compile time,在这个阶段，编译器会检查你的代码的正确性，
并且把你的代码转化为目标文件。
当你在运行你的程序时，叫做runtime,在这个阶段你的程序逐行执行。
</p>
</div>
</div>
<div id="outline-container-org1ad9178" class="outline-4">
<h4 id="org1ad9178">const VS constexpr</h4>
<div class="outline-text-4" id="text-org1ad9178">
<p>
在C++11中有两种类型的常量分别与上述两个阶段对应：编译器常量和运行期常
,两者的共同点是在初始化后都不会再改变，两者的区别是在编译期初始化还是在运
行期初始化。编译期常量是C++11新引入的一种常量类型，使用 <code>constexpr</code> 标志符。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">gravity</span><span class="org-rainbow-delimiters-depth-1">{</span>9.8<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"Enter your age:"</span>;
<span class="linenr"> 4: </span><span class="org-type">int</span> <span class="org-variable-name">age</span>;
<span class="linenr"> 5: </span><span class="org-constant">std</span>::cin&gt;&gt;age;
<span class="linenr"> 6: </span><span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">myAge</span> = age;      <span class="org-comment-delimiter">//</span><span class="org-comment">can't use const</span>
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span><span class="org-type">void</span> <span class="org-function-name">printInt</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">myValue</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment-delimiter">//</span><span class="org-comment">can't use constexpr</span>
<span class="linenr"> 9: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">10: </span><span class="org-constant">std</span>::cout&lt;&lt;myValue;
<span class="linenr">11: </span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8500cf2" class="outline-4">
<h4 id="org8500cf2">top-level const VS low-level const</h4>
<div class="outline-text-4" id="text-org8500cf2">
<p>
top-level const 表示对象本身是个const,low-level const 与指针或引用等复合类型的基
本类型部分有关。
</p>

<p>
当执行拷贝操作时，顶层const 不受什么影响；而底层const 有如下限制：拷入和拷出的对
象必须具有相同的底层const 资格，或者两个对象的数据类型能够相互转换。一般来说，非
常量可以转化为常量，反之不行。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0;
<span class="linenr"> 2: </span><span class="org-type">int</span> *<span class="org-keyword">const</span> <span class="org-variable-name">p1</span> = &amp;i;       <span class="org-comment-delimiter">//</span><span class="org-comment">&#39030;&#23618;const</span>
<span class="linenr"> 3: </span><span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">ci</span> = 42;        <span class="org-comment-delimiter">//</span><span class="org-comment">&#39030;&#23618;const</span>
<span class="linenr"> 4: </span><span class="org-keyword">const</span> <span class="org-type">int</span> *<span class="org-variable-name">p2</span> = &amp;ci;      <span class="org-comment-delimiter">//</span><span class="org-comment">&#24213;&#23618;const</span>
<span class="linenr"> 5: </span><span class="org-keyword">const</span> <span class="org-type">int</span> *<span class="org-keyword">const</span> <span class="org-variable-name">p3</span> = p2; <span class="org-comment-delimiter">//</span><span class="org-comment">&#21491;&#36793;&#26159;&#39030;&#23618;const,&#24038;&#36793;&#26159;&#24213;&#23618;const</span>
<span class="linenr"> 6: </span><span class="org-keyword">const</span> <span class="org-type">int</span> &amp;<span class="org-variable-name">r</span> = ci;       <span class="org-comment-delimiter">//</span><span class="org-comment">&#29992;&#20110;&#22768;&#26126;&#24341;&#29992;&#30340;const &#37117;&#26159;&#24213;&#23618;const</span>
<span class="linenr"> 7: </span>i = ci;
<span class="linenr"> 8: </span>p2 = p3;                 <span class="org-comment-delimiter">//</span><span class="org-comment">ci,p3&#20026;&#39030;&#23618;const,&#26080;&#24433;&#21709;</span>
<span class="linenr"> 9: </span><span class="org-type">int</span>* <span class="org-variable-name">p</span> = p3;             <span class="org-comment-delimiter">//</span><span class="org-comment">Error:p3&#26377;&#24213;&#23618;const,&#32780;p &#27809;&#26377;</span>
<span class="linenr">10: </span>p2 = &amp;i;                 <span class="org-comment-delimiter">//</span><span class="org-comment">ok: int* &#21487;&#20197;&#36716;&#21270;&#20026; const int*</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8bd4d83" class="outline-4">
<h4 id="org8bd4d83">constexpr 与 指针</h4>
<div class="outline-text-4" id="text-org8bd4d83">
<p>
当使用 <code>constexpr</code> 类型的指针或引用时，指向或引用的对象必须具有静态生存期，即地
址必须是固定的。另外 <code>constexpr</code> 限定符仅对指针有效，与所指向的对象无关。也就是
该指针为顶层const.下面的例子中， <code>const</code> 说明p 具有底层const <code>constexpr</code> 说明p
具有顶层const. 其中i 具有静态生存期。
</p>
<pre class="example">
constexpr const int *p = &amp;i;
</pre>
</div>
</div>
</div>
<div id="outline-container-org6d76535" class="outline-3">
<h3 id="org6d76535">处理类型</h3>
<div class="outline-text-3" id="text-org6d76535">
</div>
<div id="outline-container-org6294b5e" class="outline-4">
<h4 id="org6294b5e">类型别名</h4>
<div class="outline-text-4" id="text-org6294b5e">
<p>
C++11 有两种方法定义类型别名
</p>
<dl class="org-dl">
<dt>typedef</dt><dd>typedef double wages;</dd>
<dt>using</dt><dd>using wages = double;</dd>
</dl>
</div>
</div>
<div id="outline-container-org1a4fb87" class="outline-4">
<h4 id="org1a4fb87">auto 类型说明符</h4>
<div class="outline-text-4" id="text-org1a4fb87">
<p>
C++11 引入了 <code>auto</code> 说明符，可以让编译器根据变量的初始值推断变量的类型。因此
<code>auto</code> 定义的变量必须有初始值。 <code>auto</code> 通常会忽略掉顶层const,而底层const 则会保
留下来。
</p>
</div>
</div>
<div id="outline-container-org7a72612" class="outline-4">
<h4 id="org7a72612">decltype类型指示符</h4>
<div class="outline-text-4" id="text-org7a72612">
<p>
有时候会希望使用表达式的类型推断处表达式的类型，但是又不想用表达式的值初始化变量，
C++11 中的 <code>decltype</code> 类型指示符就可以实现。
</p>
<pre class="example">
decltype(f()) v = x;
</pre>

<p>
编译器不会调用 f(),而是将 f() 的返回类型作为 v 的类型。
如果 <code>decltype</code> 使用的表达式是一个变量，则返回改变量的类型（包括顶层const 和引用
在内）。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">ci</span> = 0;
<span class="linenr">2: </span><span class="org-keyword">const</span> <span class="org-type">int</span> &amp;<span class="org-variable-name">cj</span> = ci;
<span class="linenr">3: </span><span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-1">(</span>ci<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-variable-name">x</span> = 0;  <span class="org-comment-delimiter">//</span><span class="org-comment">x &#26159;const int</span>
<span class="linenr">4: </span><span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-1">(</span>cj<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-variable-name">y</span> = x;  <span class="org-comment-delimiter">//</span><span class="org-comment">y &#26159;const int&amp;</span>
</pre>
</div>

<p>
<b>需要说明的是，引用从来都是作为其所引用对象的同义词出现，只有用在 <code>decltype</code> 处是
一个例外</b>
</p>
</div>
<ul class="org-ul">
<li><a id="orga18c2bd"></a>decltype 和引用<br />
<div class="outline-text-5" id="text-orga18c2bd">
<p>
如果 <code>decltype</code> 使用的表达式不是一个变量，则 <code>decltype</code> 返回表达式结果对应的类型。
这里主要讲一下它和引用类型。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 42;
<span class="linenr">2: </span><span class="org-type">int</span> *<span class="org-variable-name">p</span> = &amp;i;
<span class="linenr">3: </span><span class="org-type">int</span> &amp;<span class="org-variable-name">r</span> = i;
<span class="linenr">4: </span><span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-1">(</span>r<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-variable-name">rr</span> = i;  <span class="org-comment-delimiter">//</span><span class="org-comment">rr &#20026;int&amp;&#24341;&#29992;&#31867;&#22411;</span>
<span class="linenr">5: </span><span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-1">(</span>r+0<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-variable-name">b</span>;     <span class="org-comment-delimiter">//</span><span class="org-comment">b &#20026;int</span>
<span class="linenr">6: </span><span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-1">(</span>*p<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-variable-name">c</span> = b;  <span class="org-comment-delimiter">//</span><span class="org-comment">c &#20026;int&amp; &#24341;&#29992;&#31867;&#22411;</span>
</pre>
</div>

<p>
对于变量b,由于r+0结果是整型，所以b的类型也是整型。对于c,解引用指针可以得到指针所
指的对象，而且还能给这个对象赋值，因此c的类型就是 <code>int&amp;</code> ,而非 <code>int</code>.
<b>Note</b>: <code>decltype(variable)</code> 的结果只有当变量本身是引用时才是引用；
<code>decltype((variable))</code> 的结果永远是引用。
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org6326de2" class="outline-3">
<h3 id="org6326de2">内置数组</h3>
<div class="outline-text-3" id="text-org6326de2">
<p>
数组是存放相同类型对象的容器，是一种复合类型，這些对象本身没有名字，需要通过其所在位置访问，数组
的大小确定不变，不能随意向数组中增加元素。数组的元素必须是对象，不能是引用类型。
</p>
</div>
<div id="outline-container-org9e36925" class="outline-4">
<h4 id="org9e36925">数组的定义和初始化</h4>
<div class="outline-text-4" id="text-org9e36925">
<p>
<code>TYPE ARRAYNAME[LENGHTH]</code>
我们使用方括号 <code>[]</code> 来告诉编译器我们定义的变量是一个数组而不是一个普通变量，而且
也告诉编译器数组的维度 <code>LENGHTH</code> ，元素的类型为 <code>TYPE</code> ,而数组的名称为
<code>ARRAYNAME</code>. 理解数组的定义形式对于理解复杂的数组很有帮助：我们通过方括号来确定
这个变量是数组，方括号内的常量表达式指定数组的大小，最后数组元素的类型由最左边的
类型指定，可以通过数组名称使用数组。可以对数组元素进行列表初始化。
</p>

<p>
数组有一个非常重要的特性： <b>不允许拷贝和赋值</b> :
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="linenr">1: </span><span class="org-type">int</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">[]</span> = <span class="org-rainbow-delimiters-depth-1">{</span>0,1,2<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="linenr">2: </span><span class="org-type">int</span> <span class="org-variable-name">a2</span><span class="org-rainbow-delimiters-depth-1">[]</span> = a;        <span class="org-comment-delimiter">//</span><span class="org-comment">error:&#25968;&#32452;&#19981;&#20801;&#35768;&#25335;&#36125;</span>
<span class="linenr">3: </span>a2 = a;              <span class="org-comment-delimiter">//</span><span class="org-comment">error:&#25968;&#32452;&#19981;&#20801;&#35768;&#36171;&#20540;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf4e9ff3" class="outline-4">
<h4 id="orgf4e9ff3">理解复杂的数组声明</h4>
<div class="outline-text-4" id="text-orgf4e9ff3">
<p>
当数组的声明中有指针及引用等符号时，就显得比较复杂。要理解复杂的数组声明，关键是
要认清数组声明的本质：先刨除数组名称，主要考察 <code>TYPE [LENGTH]</code>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-type">int</span> <span class="org-variable-name">arr</span><span class="org-rainbow-delimiters-depth-1">[</span>10<span class="org-rainbow-delimiters-depth-1">]</span>;                     <span class="org-comment-delimiter">//</span><span class="org-comment">&#21253;&#21547;10&#20010;&#25972;&#25968;&#30340;&#25968;&#32452;</span>
<span class="linenr">2: </span><span class="org-type">int</span> *<span class="org-variable-name">ptrs</span><span class="org-rainbow-delimiters-depth-1">[</span>10<span class="org-rainbow-delimiters-depth-1">]</span>;                   <span class="org-comment-delimiter">//</span><span class="org-comment">&#21253;&#21547;10&#20010;&#25972;&#22411;&#25351;&#38024;&#30340;&#25968;&#32452;</span>
<span class="linenr">3: </span><span class="org-type">int</span> &amp;<span class="org-variable-name">refs</span><span class="org-rainbow-delimiters-depth-1">[</span>10<span class="org-rainbow-delimiters-depth-1">]</span>;                   <span class="org-comment-delimiter">//</span><span class="org-comment">error:&#25968;&#32452;&#30340;&#20803;&#32032;&#31867;&#22411;&#24517;&#39035;&#26159;&#23545;&#35937;&#65292;&#19981;&#33021;&#26159;&#24341;&#29992;&#31867;&#22411;</span>
<span class="linenr">4: </span><span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-1">(</span>*<span class="org-variable-name">parrary</span><span class="org-rainbow-delimiters-depth-1">)[</span>10<span class="org-rainbow-delimiters-depth-1">]</span> = &amp;arr;       <span class="org-comment-delimiter">//</span><span class="org-comment">&#25351;&#21521;int[10]&#25968;&#32452;&#30340;&#25351;&#38024;&#65307; &#25968;&#32452;&#21517;&#30001; * &#20462;&#39280;</span>
<span class="linenr">5: </span><span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-variable-name">arrRef</span><span class="org-rainbow-delimiters-depth-1">)[</span>10<span class="org-rainbow-delimiters-depth-1">]</span> = arr;         <span class="org-comment-delimiter">//</span><span class="org-comment">int[10]&#25968;&#32452;&#30340;&#24341;&#29992;</span>
<span class="linenr">6: </span><span class="org-type">int</span>*<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-variable-name">arry</span><span class="org-rainbow-delimiters-depth-1">)[</span>10<span class="org-rainbow-delimiters-depth-1">]</span> = ptrs;          <span class="org-comment-delimiter">//</span><span class="org-comment">int* [10]&#25968;&#32452;&#30340;&#24341;&#29992;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcba3034" class="outline-4">
<h4 id="orgcba3034">访问数组元素</h4>
<div class="outline-text-4" id="text-orgcba3034">
<p>
数组元素可以用范围 <code>for</code> 语句或下标运算符访问，数组下标通常被定义为 <code>size_t</code> 类
型，是一种与机器无关的无符号类型，但是在使用下标的时候必须要保证下标在合理的范围
之内，防止下标越界。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 2: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr"> 3: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 4: </span>    <span class="org-type">double</span> <span class="org-variable-name">scores</span><span class="org-rainbow-delimiters-depth-2">[]</span> = <span class="org-rainbow-delimiters-depth-2">{</span>90.0,83.3,75.1<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="linenr"> 5: </span>    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span> <span class="org-variable-name">i</span> : scores<span class="org-rainbow-delimiters-depth-2">)</span>
<span class="linenr"> 6: </span>    <span class="org-rainbow-delimiters-depth-2">{</span>
<span class="linenr"> 7: </span>        <span class="org-constant">std</span>::cout&lt;&lt;i&lt;&lt;<span class="org-string">" "</span>;
<span class="linenr"> 8: </span>    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="linenr"> 9: </span>    <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"\n"</span>;
<span class="linenr">10: </span>    <span class="org-keyword">return</span> 0;
<span class="linenr">11: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">12: </span>
</pre>
</div>

<pre class="example">
90 83.3 75.1
</pre>
</div>
</div>
<div id="outline-container-orgde5dbc3" class="outline-4">
<h4 id="orgde5dbc3">数组与指针</h4>
<div class="outline-text-4" id="text-orgde5dbc3">
<p>
在使用数组时，编译器一般会把它转变为指针：在很多用到数组名字的地方，编译器会自动
将其转换为指向首元素的指针。但是有一种情况例外 <code>decltype</code>:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 2: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr"> 3: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 4: </span>    <span class="org-type">int</span> <span class="org-variable-name">ia</span><span class="org-rainbow-delimiters-depth-2">[]{</span>1,2,3,4,5<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="linenr"> 5: </span>    <span class="org-keyword">auto</span> <span class="org-variable-name">ia2</span><span class="org-rainbow-delimiters-depth-2">(</span>ia<span class="org-rainbow-delimiters-depth-2">)</span>;        <span class="org-comment-delimiter">//</span><span class="org-comment">ia2&#26159;&#25351;&#38024;&#31867;&#22411;</span>
<span class="linenr"> 6: </span>    *ia2 = 6;
<span class="linenr"> 7: </span>    <span class="org-constant">std</span>::cout&lt;&lt;ia<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span>&lt;&lt;<span class="org-string">"\n"</span>;
<span class="linenr"> 8: </span>    <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-2">(</span>ia<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-variable-name">ia3</span> = <span class="org-rainbow-delimiters-depth-2">{</span>6,7,8,9,0<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="linenr"> 9: </span>    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">e</span> : ia3<span class="org-rainbow-delimiters-depth-2">)</span>
<span class="linenr">10: </span>        <span class="org-constant">std</span>::cout&lt;&lt;e&lt;&lt;<span class="org-string">" "</span>;
<span class="linenr">11: </span>    <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"\n"</span>;
<span class="linenr">12: </span>    <span class="org-keyword">return</span> 0;
<span class="linenr">13: </span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<pre class="example">
6
6 7 8 9 0
</pre>


<p>
除了使用数组可以获得首元素的指针以外，还可以使用标准库函数(begin end)获得首元素和尾后元素的
指针，它们定义在 <code>iterator</code> 头文件中，
</p>
</div>
<ul class="org-ul">
<li><a id="org7cf5e6c"></a>指针运算<br />
<div class="outline-text-5" id="text-org7cf5e6c">
<p>
指针可以进行解引用，递增递减，与整数相加减，两个指针比较大小，两个指针相减等操作。
与整数相加减是地址前进了该整数个距离(大小由类型决定),结果仍是指针；两个指针相减
的结果是它们之间的距离，参与运算的两个指针必须指向同一个数组中的元素，结果类型是
<code>ptediff_t</code>,是一种带符号类型， 这样的两个指针还能比较大小，通常数组后面的指针比
前面的大。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 2: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iterator</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 3: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr"> 4: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 5: </span>    <span class="org-type">int</span> <span class="org-variable-name">arr</span><span class="org-rainbow-delimiters-depth-2">[]{</span>1,2,3,4,5<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="linenr"> 6: </span>    <span class="org-keyword">auto</span> <span class="org-variable-name">diff</span> = <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-2">(</span>arr<span class="org-rainbow-delimiters-depth-2">)</span> - <span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-2">(</span>arr<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr"> 7: </span>    <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"diff is "</span>&lt;&lt;diff&lt;&lt;<span class="org-string">"\n"</span>;
<span class="linenr"> 8: </span>    <span class="org-keyword">auto</span> <span class="org-variable-name">b</span> = <span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-2">(</span>arr<span class="org-rainbow-delimiters-depth-2">)</span>+1;
<span class="linenr"> 9: </span>    <span class="org-keyword">auto</span> <span class="org-variable-name">e</span> = <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-2">(</span>arr<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr">10: </span>    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span>b &lt; e<span class="org-rainbow-delimiters-depth-2">)</span>
<span class="linenr">11: </span>    <span class="org-rainbow-delimiters-depth-2">{</span>
<span class="linenr">12: </span>        <span class="org-constant">std</span>::cout&lt;&lt; *b++&lt;&lt;<span class="org-string">" "</span>;
<span class="linenr">13: </span>    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="linenr">14: </span>
<span class="linenr">15: </span>    <span class="org-keyword">return</span> 0;
<span class="linenr">16: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">17: </span>
</pre>
</div>

<pre class="example">
diff is 5
2 3 4 5
</pre>
</div>
</li>
<li><a id="orgbe2014e"></a>下标和指针<br />
<div class="outline-text-5" id="text-orgbe2014e">
<p>
当对数组使用下标运算符时，编译器会自动将数组名称变为指向首元素的指针；只要指针指
向的是数组元素（或者尾后元素），都可以对指针进行下标运算。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-type">int</span> <span class="org-variable-name">arr</span><span class="org-rainbow-delimiters-depth-1">[]{</span>1,2,3,4,5<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="linenr">2: </span>arr<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> = 90;                  <span class="org-comment-delimiter">//</span><span class="org-comment">&#30456;&#24403;&#20110; *(arr+3) = 90</span>
<span class="linenr">3: </span><span class="org-type">int</span> *<span class="org-variable-name">p</span> = arr;
<span class="linenr">4: </span><span class="org-type">int</span> <span class="org-variable-name">i</span> = *<span class="org-rainbow-delimiters-depth-1">(</span>p+3<span class="org-rainbow-delimiters-depth-1">)</span>;               <span class="org-comment-delimiter">//</span><span class="org-comment">&#30456;&#24403;&#20110;int i = arr[3]</span>
<span class="linenr">5: </span>p<span class="org-rainbow-delimiters-depth-1">[</span>4<span class="org-rainbow-delimiters-depth-1">]</span> = 8;                     <span class="org-comment-delimiter">//</span><span class="org-comment">&#30456;&#24403;&#20110;ia[4] = 8</span>
</pre>
</div>
</div>
</li>

<li><a id="orgf6d6ef8"></a>使用数组初始化 vector<br />
<div class="outline-text-5" id="text-orgf6d6ef8">
<p>
虽然不允许内置数组之间拷贝和赋值，也不允许用 <code>vector</code> 为数组初始化，但是可以使用
内置数组为 <code>vector</code> 对象赋初值。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 2: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iterator</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 3: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 4: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr"> 5: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 6: </span>    <span class="org-type">int</span> <span class="org-variable-name">arr</span><span class="org-rainbow-delimiters-depth-2">[]</span> = <span class="org-rainbow-delimiters-depth-2">{</span>1,2,3,4,5,6,7,8,9,0<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="linenr"> 7: </span>    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">veci</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>arr<span class="org-rainbow-delimiters-depth-3">)</span>,<span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>arr<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="linenr"> 8: </span>    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span> &amp; <span class="org-variable-name">e</span> : veci<span class="org-rainbow-delimiters-depth-2">)</span>
<span class="linenr"> 9: </span>        <span class="org-constant">std</span>::cout&lt;&lt;e&lt;&lt;<span class="org-string">" "</span>;
<span class="linenr">10: </span>    <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"\n"</span>;
<span class="linenr">11: </span>    <span class="org-keyword">return</span> 0;
<span class="linenr">12: </span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<pre class="example">
1 2 3 4 5 6 7 8 9 0
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-org1795da5" class="outline-4">
<h4 id="org1795da5">动态数组</h4>
<div class="outline-text-4" id="text-org1795da5">
<p>
C++除了固定大小的数组，还有动态数组，与固定大小的内置数组相比，动态数组的大小可
以在运行期确定。为了定义动态数组，我们使用 <code>new[]</code> 创建空间， <code>delete[]</code> 释放空
间。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 2: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr"> 3: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 4: </span>    <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"Enter a positive integer:\n"</span>;
<span class="linenr"> 5: </span>    <span class="org-type">int</span> <span class="org-variable-name">length</span>;
<span class="linenr"> 6: </span>    <span class="org-constant">std</span>::cin&gt;&gt;length;
<span class="linenr"> 7: </span>    <span class="org-type">int</span> *<span class="org-variable-name">arr</span> = <span class="org-keyword">new</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">[</span>length<span class="org-rainbow-delimiters-depth-2">]</span>;
<span class="linenr"> 8: </span>    <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"I just allocate an array of length:"</span>&lt;&lt;length&lt;&lt;<span class="org-string">"\n"</span>;
<span class="linenr"> 9: </span>    <span class="org-keyword">delete</span> <span class="org-rainbow-delimiters-depth-2">[]</span> arr;
<span class="linenr">10: </span>    <span class="org-keyword">return</span> 0;
<span class="linenr">11: </span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<pre class="example">
Enter a positive integer:
I just allocate an array of length:22082
</pre>
</div>

<ul class="org-ul">
<li><a id="org62ea3a2"></a>维度与初始化<br />
<div class="outline-text-5" id="text-org62ea3a2">
<p>
动态数组必须指定大小，而不能像固定大小数组那样可以缺省大小；如果想要初始化可以使
用列表初始化，
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-type">int</span> * <span class="org-variable-name">arr</span> = <span class="org-keyword">new</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">[</span>5<span class="org-rainbow-delimiters-depth-1">]{</span>2,4,6,8,0<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</div>
</li>

<li><a id="org5a39470"></a>改变大小<br />
<div class="outline-text-5" id="text-org5a39470">
<p>
尽管动态数组可以在运行期确定大小，但是C++没有提供改变一个已经分配了内存空间的动
态数组的内置方法，这个限制可以这样克服：重新分配一块新的内存空间，拷贝原动态数组
内容到新的内存空间，删除原动态数组。
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org3d520da" class="outline-4">
<h4 id="org3d520da">多维数组</h4>
<div class="outline-text-4" id="text-org3d520da">
<p>
C++中的多维数组其实就是数组的数组，多维数组可以有多个维度，按照从内到外的顺序阅
读此类定义有助于更好的理解其真实含义。例如：
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-type">int</span> <span class="org-variable-name">ia</span><span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">][</span>4<span class="org-rainbow-delimiters-depth-1">]</span>;
</pre>
</div>

<p>
定义了一个大小为3的数组，该数组的每个元素都是含有4个整数的数组。对于二维数组来说，
常把第一个维度称为行，第二个维度称为列。
</p>
</div>
<ul class="org-ul">
<li><a id="org3dcd12d"></a>多维数组的下标运算<br />
<div class="outline-text-5" id="text-org3dcd12d">
<p>
可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。如
果表达式含有的下标运算符数量与数组的维度一样多，该表达式的结果将是给定类型的元素；
反之，如果表达式含有的下标运算符数量比数组维度小，则表达式的结果将是给定索引处的
一个内层数组。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-type">int</span> <span class="org-variable-name">arr</span><span class="org-rainbow-delimiters-depth-1">[</span>10<span class="org-rainbow-delimiters-depth-1">][</span>20<span class="org-rainbow-delimiters-depth-1">][</span>30<span class="org-rainbow-delimiters-depth-1">]</span> = <span class="org-rainbow-delimiters-depth-1">{</span>0<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">//</span><span class="org-comment">&#23558;&#25152;&#26377;&#20803;&#32032;&#21021;&#22987;&#21270;&#20026;0</span>
<span class="linenr">2: </span><span class="org-type">int</span> <span class="org-variable-name">ia</span><span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">][</span>4<span class="org-rainbow-delimiters-depth-1">]</span> = <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">3: </span>    <span class="org-rainbow-delimiters-depth-2">{</span>0,1,2,3<span class="org-rainbow-delimiters-depth-2">}</span>,
<span class="linenr">4: </span>    <span class="org-rainbow-delimiters-depth-2">{</span>4,5,6,7<span class="org-rainbow-delimiters-depth-2">}</span>,
<span class="linenr">5: </span>    <span class="org-rainbow-delimiters-depth-2">{</span>8,9,10,11<span class="org-rainbow-delimiters-depth-2">}</span>,
<span class="linenr">6: </span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="linenr">7: </span>
<span class="linenr">8: </span>ia<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">][</span>3<span class="org-rainbow-delimiters-depth-1">]</span> = arr<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">][</span>0<span class="org-rainbow-delimiters-depth-1">][</span>0<span class="org-rainbow-delimiters-depth-1">]</span>;
<span class="linenr">9: </span><span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-variable-name">row</span><span class="org-rainbow-delimiters-depth-1">)[</span>4<span class="org-rainbow-delimiters-depth-1">]</span> = ia<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>;    <span class="org-comment-delimiter">//</span><span class="org-comment">&#23558;row &#32465;&#23450;&#21040;&#31532;&#20108;&#20010;4&#20803;&#32032;&#25968;&#32452;&#19978;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 2: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr"> 3: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 4: </span>    <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">rowCnt</span> = 3;
<span class="linenr"> 5: </span>    <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">colCnt</span> = 4;
<span class="linenr"> 6: </span>    <span class="org-type">int</span> <span class="org-variable-name">ia</span><span class="org-rainbow-delimiters-depth-2">[</span>rowCnt<span class="org-rainbow-delimiters-depth-2">][</span>colCnt<span class="org-rainbow-delimiters-depth-2">]</span>;
<span class="linenr"> 7: </span>    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; rowCnt; ++i<span class="org-rainbow-delimiters-depth-2">)</span>
<span class="linenr"> 8: </span>    <span class="org-rainbow-delimiters-depth-2">{</span>
<span class="linenr"> 9: </span>        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">j</span> = 0; j &lt; colCnt; ++j<span class="org-rainbow-delimiters-depth-3">)</span>
<span class="linenr">10: </span>        <span class="org-rainbow-delimiters-depth-3">{</span>
<span class="linenr">11: </span>            ia<span class="org-rainbow-delimiters-depth-4">[</span>i<span class="org-rainbow-delimiters-depth-4">][</span>j<span class="org-rainbow-delimiters-depth-4">]</span> = i * colCnt + j;
<span class="linenr">12: </span>        <span class="org-rainbow-delimiters-depth-3">}</span>
<span class="linenr">13: </span>    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="linenr">14: </span>    <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> &amp;<span class="org-variable-name">row</span> : ia<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>        <span class="org-comment-delimiter">//</span><span class="org-comment">&#20043;&#25152;&#20197;&#20351;&#29992;&#24341;&#29992;&#26159;&#20026;&#20102;&#36991;&#20813;&#25968;&#32452;&#36864;&#21270;&#20026;&#25351;&#38024;</span>
<span class="linenr">15: </span>        <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> &amp;<span class="org-variable-name">col</span> : row<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>
<span class="linenr">16: </span>            <span class="org-constant">std</span>::cout&lt;&lt;col&lt;&lt;<span class="org-string">" "</span>;
<span class="linenr">17: </span>        <span class="org-rainbow-delimiters-depth-3">}</span>
<span class="linenr">18: </span>
<span class="linenr">19: </span>    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="linenr">20: </span>
<span class="linenr">21: </span>    <span class="org-keyword">return</span> 0;
<span class="linenr">22: </span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<pre class="example">
0 1 2 3 4 5 6 7 8 9 10 11
</pre>

<p>
<b>Note</b>: 要使用范围 <code>for</code> 语句处理多维数组，除了最内层的循环外，其它所有循环的控
制变量都应该使用引用类型。
</p>
</div>
</li>
<li><a id="orge6cea09"></a>指针和多维数组<br />
<div class="outline-text-5" id="text-orge6cea09">
<p>
当程序使用多维数组的名字时，也会自动将其转换为指向数组首元素(第一个内层数组)的指
针，
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 2: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iterator</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 3: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr"> 4: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 5: </span>    <span class="org-type">int</span> <span class="org-variable-name">ia</span><span class="org-rainbow-delimiters-depth-2">[</span>3<span class="org-rainbow-delimiters-depth-2">][</span>4<span class="org-rainbow-delimiters-depth-2">]</span> =
<span class="linenr"> 6: </span>        <span class="org-rainbow-delimiters-depth-2">{</span>
<span class="linenr"> 7: </span>            <span class="org-rainbow-delimiters-depth-3">{</span>0,1,2,3<span class="org-rainbow-delimiters-depth-3">}</span>,
<span class="linenr"> 8: </span>            <span class="org-rainbow-delimiters-depth-3">{</span>4,5,6,7<span class="org-rainbow-delimiters-depth-3">}</span>,
<span class="linenr"> 9: </span>            <span class="org-rainbow-delimiters-depth-3">{</span>8,9,10,11<span class="org-rainbow-delimiters-depth-3">}</span>,
<span class="linenr">10: </span>        <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="linenr">11: </span>
<span class="linenr">12: </span>    <span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-variable-name">p</span><span class="org-rainbow-delimiters-depth-2">)[</span>4<span class="org-rainbow-delimiters-depth-2">]</span> = ia;  <span class="org-comment-delimiter">//</span><span class="org-comment">&#25351;&#21521;ia[0]</span>
<span class="linenr">13: </span>    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">e</span> = <span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>*p<span class="org-rainbow-delimiters-depth-3">)</span>;e != <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>*p<span class="org-rainbow-delimiters-depth-3">)</span>; ++e<span class="org-rainbow-delimiters-depth-2">)</span>   <span class="org-comment-delimiter">//</span><span class="org-comment">*p &#30340;&#31867;&#22411;&#20026;int[4],&#26102;&#25968;&#32452;&#65307;e &#26159;&#35813;&#25968;&#32452;&#30340;&#36845;&#20195;&#22120;</span>
<span class="linenr">14: </span>        <span class="org-constant">std</span>::cout&lt;&lt;*e&lt;&lt;<span class="org-string">" "</span>;
<span class="linenr">15: </span>    <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"\n"</span>;
<span class="linenr">16: </span>
<span class="linenr">17: </span>    p = &amp;ia<span class="org-rainbow-delimiters-depth-2">[</span>2<span class="org-rainbow-delimiters-depth-2">]</span>;        <span class="org-comment-delimiter">//</span><span class="org-comment">&#25351;&#21521;ia[2]</span>
<span class="linenr">18: </span>    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">e</span> : *p<span class="org-rainbow-delimiters-depth-2">)</span>   <span class="org-comment-delimiter">//</span><span class="org-comment">e &#26159;int &#31867;&#22411;&#65292;&#20026;&#25968;&#32452;&#20013;&#30340;&#20803;&#32032;</span>
<span class="linenr">19: </span>        <span class="org-constant">std</span>::cout&lt;&lt;e&lt;&lt;<span class="org-string">" "</span>;
<span class="linenr">20: </span>    <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"\n"</span>;
<span class="linenr">21: </span>    <span class="org-keyword">return</span> 0;
<span class="linenr">22: </span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<pre class="example">
0 1 2 3
8 9 10 11
</pre>

<p>
使用类型别名可以简化指向多维数组的指针，让人更容易理解这类指针。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 2: </span><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iterator</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="linenr"> 3: </span><span class="org-keyword">typedef</span> <span class="org-type">int</span> <span class="org-type">intArrFoure</span><span class="org-rainbow-delimiters-depth-1">[</span>4<span class="org-rainbow-delimiters-depth-1">]</span>;
<span class="linenr"> 4: </span><span class="org-comment-delimiter">// </span><span class="org-comment">using intArrFoure = int[4]; //c++11&#20013;&#30340;&#31561;&#20215;&#34920;&#36798;&#24335;</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="linenr"> 7: </span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr"> 8: </span>    <span class="org-type">int</span> <span class="org-variable-name">ia</span><span class="org-rainbow-delimiters-depth-2">[</span>3<span class="org-rainbow-delimiters-depth-2">][</span>4<span class="org-rainbow-delimiters-depth-2">]</span> =
<span class="linenr"> 9: </span>        <span class="org-rainbow-delimiters-depth-2">{</span>
<span class="linenr">10: </span>            <span class="org-rainbow-delimiters-depth-3">{</span>0,1,2,3<span class="org-rainbow-delimiters-depth-3">}</span>,
<span class="linenr">11: </span>            <span class="org-rainbow-delimiters-depth-3">{</span>4,5,6,7<span class="org-rainbow-delimiters-depth-3">}</span>,
<span class="linenr">12: </span>            <span class="org-rainbow-delimiters-depth-3">{</span>8,9,10,11<span class="org-rainbow-delimiters-depth-3">}</span>,
<span class="linenr">13: </span>        <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="linenr">14: </span>    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">intArrFoure</span> *<span class="org-variable-name">p</span> = ia; p != ia+3; ++p<span class="org-rainbow-delimiters-depth-2">)</span>
<span class="linenr">15: </span>        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">e</span> : *p<span class="org-rainbow-delimiters-depth-2">)</span>
<span class="linenr">16: </span>            <span class="org-constant">std</span>::cout&lt;&lt;e&lt;&lt;<span class="org-string">" "</span>;
<span class="linenr">17: </span>    <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"\n"</span>;
<span class="linenr">18: </span>    <span class="org-keyword">return</span> 0;
<span class="linenr">19: </span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="linenr">20: </span>
</pre>
</div>

<pre class="example">
0 1 2 3 4 5 6 7 8 9 10 11
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org90cb3d3" class="outline-3">
<h3 id="org90cb3d3">枚举类型</h3>
<div class="outline-text-3" id="text-org90cb3d3">
<p>
枚举类型可以将一组整型常量组织在一起，枚举属于字面值常量类型，每个枚举类型定义了
一个新的类型。C++有两种枚举类型，限定作用域(scoped)和不限定作用域 (unscoped),区
别在于前者有 <code>class</code> 或 <code>struct</code> 关键字，后者没有。
</p>
</div>
<div id="outline-container-org20dd519" class="outline-4">
<h4 id="org20dd519">枚举成员</h4>
<div class="outline-text-4" id="text-org20dd519">
<p>
枚举类型大括号扩起来的以逗号分隔的枚举成员列表，
</p>
</div>
<ul class="org-ul">
<li><a id="org0d7df74"></a>作用域<br />
<div class="outline-text-5" id="text-org0d7df74">
<p>
不限定作用域的枚举类型的成员的作用域与枚举类型相同，限定作用域的枚举类型的成员的
名字遵循常规的作用域准则，并且在枚举类型的作用域外不可访问。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-keyword">enum</span> <span class="org-type">color</span><span class="org-rainbow-delimiters-depth-1">{</span><span class="org-variable-name">red</span>,<span class="org-variable-name">yellow</span>,<span class="org-variable-name">green</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="linenr">2: </span><span class="org-comment-delimiter">// </span><span class="org-comment">enum stoplight{red,yellow,green}; //Error:&#21517;&#23383;&#20914;&#31361;</span>
<span class="linenr">3: </span><span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">peppers</span><span class="org-rainbow-delimiters-depth-1">{</span><span class="org-variable-name">red</span>,<span class="org-variable-name">yellow</span>,<span class="org-variable-name">green</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="linenr">4: </span><span class="org-type">color</span> <span class="org-variable-name">eye</span> = green;
<span class="linenr">5: </span><span class="org-type">peppers</span> <span class="org-variable-name">p</span> = <span class="org-constant">peppers</span>::green;  <span class="org-comment-delimiter">//</span><span class="org-comment">ok</span>
</pre>
</div>
</div>
</li>

<li><a id="org2c6f90f"></a>const 属性<br />
<div class="outline-text-5" id="text-org2c6f90f">
<p>
每个枚举成员都是一个常量表达式，默认枚举成员的值从0开始，往后依次加1,但是也可以
显式初始化，可以让多个枚举成员具有相同的值。
</p>
</div>
</li>
<li><a id="orged41011"></a>数据类型<br />
<div class="outline-text-5" id="text-orged41011">
<p>
枚举成员都是由某种整数表示的，在C++11中，我们可以指定成员的类型：
</p>
<pre class="example">
enum intVal : unsigned long long {...};
</pre>

<p>
限定作用域的枚举成员类型默认是 <code>int</code>,对于不限定作用域的枚举类型，其成员不存在默
认类型，我们只知道其类型足够大。
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org661778d" class="outline-4">
<h4 id="org661778d">前置声明</h4>
<div class="outline-text-4" id="text-org661778d">
<p>
在C++11中可以提前声明枚举类型，在其前置声明中，必须要指定枚举成员的数据类型（限
定作用域的可以使用默认值int）
</p>
</div>
</div>
<div id="outline-container-org0bc58a1" class="outline-4">
<h4 id="org0bc58a1">形参匹配</h4>
<div class="outline-text-4" id="text-org0bc58a1">
<p>
要想初始化一个 <code>enum</code> 对象，必须使用该 <code>enum</code> 类型的另一个对象，或者它的一个枚举
成员，因此，及时某个整数值恰好与枚举成员的值相等，它也不能作为函数的 <code>enum</code> 实参
使用。
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org6d2671b" class="outline-2">
<h2 id="org6d2671b">名字的作用域、生存期、链接性</h2>
<div class="outline-text-2" id="text-org6d2671b">
<p>
一个名字通常具有以下三个属性：
</p>
<dl class="org-dl">
<dt>scope</dt><dd>determines where a variable is accessable
<dl class="org-dl">
<dt><i>local scope</i></dt><dd><b>local variables(defined inside a function), function
parameters,locally-defined types</b> :only accessable at the
point of declaration and go out of scope at the end of the
block they are defined in.they have automatic duration and
no linkage.</dd>

<dt><i>file scope</i></dt><dd><b>global variables(defined outside a function),normal
functions,global-defined types</b> :accessable from
the place it declared to the end of the file;they have
static duration;if it has extern linkage,it can be
accessable in another file with forward declaration,if it
has internal linkage,it can only be used in the file it is defined.</dd>
</dl></dd>

<dt>duration</dt><dd>determines where it is created and destroyed
<dl class="org-dl">
<dt><i>automatic duration</i></dt><dd><b>normal local variables</b> : duration automatic managed by stack</dd>
<dt><i>static duration</i></dt><dd><b>static local variables,global variables</b> :created when
program begins and destroyed when program ends.</dd>
<dt><i>dynamic duration</i></dt><dd><b>dynamically allocated variables</b> :created and
destroyed by programmer request.</dd>
</dl></dd>

<dt>linkage</dt><dd>determines whether multiple instances of an identifier refer to the
same variable or not,

<dl class="org-dl">
<dt><i>internal linkage</i></dt><dd>identifier can be accessd anywhere within the file it
is declared,this includes:
<ul class="org-ul">
<li>static global variables</li>

<li>const global variables</li>

<li>static functions</li>
</ul></dd>

<dt><i>extern linkage</i></dt><dd>identifier can be accessd anywhere within the file it is
declared,or other files(via a forward declaration),this inlcudes:
<ul class="org-ul">
<li>normal funcitons</li>

<li>non-const global variables</li>

<li>extern const variables</li>

<li>user-defined types,such as enums,typedefs,and classes declared inside a block</li>
</ul></dd>
</dl></dd>
</dl>


<dl class="org-dl">
<dt><i>no linkage</i></dt><dd>mean the identifier only refers to itself,inlcudes:
<ul class="org-ul">
<li>local variables</li>

<li>user-defined types,such as enums,typedefs,and classes declared inside a
block</li>
</ul></dd>
</dl>

<p>
<b>Variable scope, duration, and linkage summary</b>
</p>

<p>
Because variables have scope, duration, and linkage, let’s summarize in a chart:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Type</td>
<td class="org-left">Example</td>
<td class="org-left">Scope</td>
<td class="org-left">Duration</td>
<td class="org-left">Linkage</td>
<td class="org-left">Notes</td>
</tr>

<tr>
<td class="org-left">Local variable</td>
<td class="org-left">int x;</td>
<td class="org-left">Block scope</td>
<td class="org-left">Automatic duration</td>
<td class="org-left">No linkage</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Static local variable</td>
<td class="org-left">static int s_x;</td>
<td class="org-left">Block scope</td>
<td class="org-left">Static duration</td>
<td class="org-left">No linkage</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Dynamic variable</td>
<td class="org-left">int *x = new int;</td>
<td class="org-left">Block scope</td>
<td class="org-left">Dynamic  duration</td>
<td class="org-left">No linkage</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Function parameter</td>
<td class="org-left">void foo(int  x)</td>
<td class="org-left">Block scope</td>
<td class="org-left">Automatic duration</td>
<td class="org-left">No linkage</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">External non-const global variable</td>
<td class="org-left">int g_x;</td>
<td class="org-left">File scope</td>
<td class="org-left">Static duration</td>
<td class="org-left">External linkage</td>
<td class="org-left">Initialized or uninitialized</td>
</tr>

<tr>
<td class="org-left">Internal non-const global variable</td>
<td class="org-left">static int g_x;</td>
<td class="org-left">File scope</td>
<td class="org-left">Static duration</td>
<td class="org-left">Internal linkage</td>
<td class="org-left">Initialized or uninitialized</td>
</tr>

<tr>
<td class="org-left">Internal const global variable</td>
<td class="org-left">const int g_x(1);</td>
<td class="org-left">File scope</td>
<td class="org-left">Static duration</td>
<td class="org-left">Internal linkage</td>
<td class="org-left">Must be initialized</td>
</tr>

<tr>
<td class="org-left">External const global variable</td>
<td class="org-left">extern const int g_x(1);</td>
<td class="org-left">File scope</td>
<td class="org-left">Static duration</td>
<td class="org-left">External linkage</td>
<td class="org-left">Must be initialized</td>
</tr>
</tbody>
</table>

<p>
<b>Forward declaration summary</b>
</p>

<p>
You can use a forward declaration to access a function or variable in another file:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Type</td>
<td class="org-left">Example</td>
<td class="org-left">Notes</td>
</tr>

<tr>
<td class="org-left">Function forward declaration</td>
<td class="org-left">void foo(int x);</td>
<td class="org-left">Prototype only,no function body</td>
</tr>

<tr>
<td class="org-left">Non-const global variable forward declaration</td>
<td class="org-left">extern int g_x;</td>
<td class="org-left">Must be uninitialized</td>
</tr>

<tr>
<td class="org-left">Const global variable forward declaration</td>
<td class="org-left">extern const int g_x;</td>
<td class="org-left">Must be uninitialized</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org532d774" class="outline-2">
<h2 id="org532d774">命名空间</h2>
<div class="outline-text-2" id="text-org532d774">
<p>
命名空间为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个
命名空间是一个作用域，只要能出现在全局作用域中的声明就能置于命名空间中，主要包括：
类、变量、函数、模板和其它命名空间。命名空间作用域后面无需分号。某个命名空间中定
义的变量可以被该命名空间或内嵌于该命名空间中的其它成员直接访问。命名空间可以是不
连续的，可以被定义在多个不同的源文件中。以下是一些特殊命名空间：
</p>
</div>
<div id="outline-container-orgf006788" class="outline-3">
<h3 id="orgf006788">内联命名空间</h3>
<div class="outline-text-3" id="text-orgf006788">
<p>
C++11引入了一种新的命名空间叫做内联命名空间(inline namespace),内联命名空间中的名
字可以被外层命名空间直接使用，关键字 <code>inline</code> 必须出现在命名空间第一次定义的地方，
后续再打开命名空间的时候可以写 <code>inline</code>,也可以不写。
</p>
</div>
</div>
<div id="outline-container-org0a05bec" class="outline-3">
<h3 id="org0a05bec">未命名的命名空间</h3>
<div class="outline-text-3" id="text-org0a05bec">
<p>
未命名的命名空间(unnamed namespace)中定义的变量拥有static duration:它们在第一次使用前创建，直到程序
结束才销毁；链接性为内部：如果两个不同文件都含有unnamed namespace,则这两个空间互
无关系，可以使用相同的名字，并且表示的是不同的实体；作用域与该命名空间所在的作用
域相同，因此定义在unnamed namespace 中的名字可以直接使用。
</p>
</div>
</div>
<div id="outline-container-org5d81146" class="outline-3">
<h3 id="org5d81146">命名空间别名</h3>
<div class="outline-text-3" id="text-org5d81146">
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span><span class="org-keyword">namespace</span> <span class="org-constant">alias</span> = <span class="org-constant">NAME1</span>::NAME2<span class="org-function-name">...</span>;
</pre>
</div>

<ul class="org-ul">
<li><a href="stl.html">C++ Standard Libarary</a></li>
<li><a href="names.html">Names And Memory Layout</a></li>
<li><a href="lei.html">Class Usage</a></li>
<li><a href="IO.html">IO lib</a></li>
<li><a href="inheritance.html">inheritance</a></li>
<li><a href="GCC_Clang_Settings.html">Setting GCC and Clang</a></li>
<li><a href="function.html">Function</a></li>
<li><a href="dynamic_memory.html">Dynamic Memory</a></li>
<li><a href="class.html">Class</a></li>
<li><a href="index.html">Index</a></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Tian Tongtong</p>
<p class="date">Created: 2020-04-11 Sat 23:07</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.0.50 (<a href="https://orgmode.org">Org</a> mode 9.3.6)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
